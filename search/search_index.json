{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"ECS/","title":"Entity Component System (ECS) Overview","text":""},{"location":"ECS/#what-is-ecs","title":"What is ECS?","text":"<p>The Entity Component System (ECS) is an architectural pattern used primarily in game development to achieve modularity, scalability, and performance. It decouples data (components) from behavior (systems) and uses entities to represent objects in the game world.</p>"},{"location":"ECS/#core-concepts","title":"Core Concepts","text":"<ol> <li>Entities: Unique identifiers (usually integers) representing objects in the game world.</li> <li>Components: Data containers holding the attributes of entities, such as position, velocity, or health.</li> <li>Systems: Logic processors that operate on entities with specific components.</li> </ol> <p>This ECS implementation leverages these principles to allow flexible management of game objects and their behaviors.</p>"},{"location":"ECS/#how-it-works","title":"How It Works","text":""},{"location":"ECS/#1-entities","title":"1. Entities","text":"<p>Entities are simply IDs that act as placeholders for components. They do not store data or behavior directly.</p> <p>Example: - Entity 1: May represent a player. - Entity 2: May represent an enemy.</p> <p>Entities gain functionality by associating them with components.</p>"},{"location":"ECS/#2-components","title":"2. Components","text":"<p>Components are plain data structures that hold attributes. Each type of component (e.g., <code>Position</code>, <code>Velocity</code>) is stored separately in the system, allowing efficient data access and manipulation.</p> <p>Example Components: - <code>Position</code>: Contains <code>x</code> and <code>y</code> coordinates. - <code>Velocity</code>: Contains <code>vx</code> and <code>vy</code> for movement speed.</p>"},{"location":"ECS/#3-systems","title":"3. Systems","text":"<p>Systems are responsible for processing entities that have the required components. For example, a <code>movement_system</code> updates the positions of all entities that have <code>Position</code> and <code>Velocity</code> components.</p>"},{"location":"ECS/#key-features-of-systems","title":"Key Features of Systems:","text":"<ul> <li>Operate only on specific components.</li> <li>Contain logic (e.g., movement, rendering).</li> <li>Decoupled from other systems, enhancing modularity.</li> </ul> <p>Example: <pre><code>void movement_system(Registry&amp; registry) {\n    auto&amp; positions = registry.get_components&lt;Position&gt;();\n    auto&amp; velocities = registry.get_components&lt;Velocity&gt;();\n\n    for (size_t i = 0; i &lt; positions.size() &amp;&amp; i &lt; velocities.size(); ++i) {\n        if (positions[i] &amp;&amp; velocities[i]) {\n            positions[i]-&gt;x += velocities[i]-&gt;vx;\n            positions[i]-&gt;y += velocities[i]-&gt;vy;\n        }\n    }\n}\n</code></pre></p>"},{"location":"ECS/#purpose-of-ecs","title":"Purpose of ECS","text":"<p>The ECS pattern separates data from behavior, allowing for: - Modularity: Systems are independent and can be added or removed without affecting others. - Performance: Grouping components by type improves memory access patterns. - Scalability: The system can manage thousands of entities efficiently.</p>"},{"location":"ECS/#how-to-use-this-ecs","title":"How to Use This ECS","text":""},{"location":"ECS/#1-creating-components","title":"1. Creating Components","text":"<p>Define components as plain data structures. <pre><code>struct Position {\n    float x, y;\n};\n\nstruct Velocity {\n    float vx, vy;\n};\n</code></pre></p>"},{"location":"ECS/#2-adding-components-to-entities","title":"2. Adding Components to Entities","text":"<p>Use the <code>Registry</code> to associate components with entities. <pre><code>Registry registry;\nEntity player = registry.create_entity();\nregistry.add_component(player, Position{0, 0});\nregistry.add_component(player, Velocity{1, 1});\n</code></pre></p>"},{"location":"ECS/#3-defining-systems","title":"3. Defining Systems","text":"<p>Create a system by inheriting from <code>SystemBase</code> or implementing a standalone function. <pre><code>class MovementSystem : public SystemBase {\npublic:\n    void update(float delta_time) override {\n    }\n};\n</code></pre></p>"},{"location":"ECS/#4-managing-systems","title":"4. Managing Systems","text":"<p>Add systems to the <code>SystemManager</code> and execute them in the game loop. <pre><code>SystemManager manager;\nmanager.add_system(std::make_shared&lt;MovementSystem&gt;());\n\nwhile (game_running) {\n    manager.update_all(delta_time);\n}\n</code></pre></p>"},{"location":"ECS/#summary","title":"Summary","text":"<p>The ECS framework provides: - A clear separation of data, behavior, and entities. - A modular approach to adding and managing systems. - Scalability for complex games with thousands of entities.</p> <p>By following these principles, developers can achieve a maintainable and efficient architecture for their game projects.</p>"},{"location":"RType/","title":"ECS-Based R-Type Architecture Documentation","text":""},{"location":"RType/#overview","title":"Overview","text":"<p>This section describes the implementation of a shooter game (RType) using the Entity Component System (ECS) framework. The game combines core ECS principles with systems such as movement, input, shooting, and rendering. Additional features include network communication and enemy behavior.</p>"},{"location":"RType/#components-and-systems","title":"Components and Systems","text":""},{"location":"RType/#1-shooting-system","title":"1. Shooting System","text":"<p>File: <code>ShootingSystem.hpp</code> - A system designed to handle shooting logic for entities. - Currently, it is a placeholder and does not contain active logic.</p>"},{"location":"RType/#key-implementation","title":"Key Implementation:","text":"<pre><code>class ShootingSystem : public SystemBase {\npublic:\n    ShootingSystem(Registry&amp; registry) : _registry(registry) {}\n\n    void update(float delta_time) override {\n    }\n\nprivate:\n    Registry&amp; _registry;\n};\n</code></pre>"},{"location":"RType/#2-game-networking","title":"2. Game Networking","text":"<p>File: <code>GameNetwork.hpp</code> - Manages communication with the game server. - Provides methods for sending and receiving messages, such as player connection, movement, and disconnection.</p>"},{"location":"RType/#key-methods","title":"Key Methods:","text":"<ol> <li><code>GameNetwork</code> Constructor:</li> <li>Establishes a TCP connection with the server.</li> <li> <p>Throws an error if the connection fails.</p> </li> <li> <p><code>sendConnectMessage</code>:</p> </li> <li> <p>Sends a message to connect the player to the server with a username.</p> </li> <li> <p><code>receivePlayerID</code>:</p> </li> <li> <p>Receives the player ID from the server after connection.</p> </li> <li> <p><code>sendMoveMessage</code>:</p> </li> <li>Sends the player's position updates to the server.</li> </ol>"},{"location":"RType/#3-game-setup-and-initialization","title":"3. Game Setup and Initialization","text":"<p>File: <code>GameSetup.hpp</code> - Configures the ECS by registering components and adding systems to the <code>SystemManager</code>. - Spawns the player entity and initializes its components.</p>"},{"location":"RType/#key-implementation_1","title":"Key Implementation:","text":"<ol> <li><code>initializeECS</code>:</li> <li>Registers all required components (e.g., <code>Position</code>, <code>Velocity</code>).</li> <li> <p>Adds systems such as <code>InputSystem</code>, <code>MovementSystem</code>, and <code>CollisionSystem</code> to the <code>SystemManager</code>.</p> </li> <li> <p><code>playGame</code>:</p> </li> <li>Spawns a player entity and initializes its components.</li> <li>Enters the main game loop, calling system updates and rendering each frame.</li> <li>Ends the game if the player's health drops to 0 or the window is closed.</li> </ol>"},{"location":"RType/#example-player-initialization","title":"Example Player Initialization:","text":"<pre><code>ECS::Entity player = registry.spawn_entity();\nregistry.get_components&lt;ECS::Position&gt;().insert_at(static_cast&lt;size_t&gt;(player), ECS::Position{100.0f, 300.0f});\nregistry.get_components&lt;ECS::Velocity&gt;().insert_at(static_cast&lt;size_t&gt;(player), ECS::Velocity{0.0f, 0.0f});\nregistry.get_components&lt;ECS::Drawable&gt;().insert_at(static_cast&lt;size_t&gt;(player), ECS::Drawable{});\nregistry.get_components&lt;ECS::InputComponent&gt;().insert_at(static_cast&lt;size_t&gt;(player), ECS::InputComponent{});\nregistry.get_components&lt;ECS::Health&gt;().insert_at(static_cast&lt;size_t&gt;(player), ECS::Health{5});\n</code></pre>"},{"location":"RType/#game-flow","title":"Game Flow","text":""},{"location":"RType/#ecs-initialization","title":"ECS Initialization","text":"<ol> <li>Register all required components with the <code>Registry</code>.</li> <li>Add systems to the <code>SystemManager</code>, specifying their priority if necessary.</li> <li>Spawn the initial player entity and configure its components.</li> </ol>"},{"location":"RType/#main-game-loop","title":"Main Game Loop","text":"<ol> <li>Update Systems:</li> <li> <p>Systems such as <code>InputSystem</code>, <code>MovementSystem</code>, and <code>CollisionSystem</code> are updated every frame based on the elapsed time (<code>delta_time</code>).</p> </li> <li> <p>Render Frame:</p> </li> <li>Clears the screen and begins drawing.</li> <li> <p>Calls the rendering system to display all drawable entities.</p> </li> <li> <p>Health Check:</p> </li> <li> <p>If the player's health reaches zero, the game transitions to the menu state.</p> </li> <li> <p>End Game:</p> </li> <li>The game ends when the player exits the window or their health depletes.</li> </ol>"},{"location":"RType/#summary","title":"Summary","text":"<p>This implementation demonstrates the integration of ECS principles into a functioning game. Key features include: - Modular design with systems for input, movement, shooting, and collision. - Efficient management of entities and components through the <code>Registry</code>. - Networking capabilities for player communication.</p> <p>By separating logic into distinct systems and leveraging the ECS architecture, the game achieves a scalable and maintainable design.</p>"},{"location":"architecture/","title":"R-Type Game Documentation","text":""},{"location":"architecture/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Project Structure</li> <li>Components</li> <li>Systems</li> <li>Managers</li> <li>Network</li> <li>Utilities</li> <li>Main Files</li> </ol>"},{"location":"architecture/#introduction","title":"Introduction","text":"<p>R-Type is a multiplayer shoot 'em up game where players control a spaceship and fight against waves of enemies. This documentation provides an overview of the project's structure, components, systems, managers, network communication, and utilities.</p>"},{"location":"architecture/#project-structure","title":"Project Structure","text":"<p>The project is organized into several directories, each containing specific types of files:</p> <p>src</p> <p>: Contains the main source code files.   - <code>ECS/</code>: Entity-Component-System architecture implementation.     - <code>include/</code>: Header files for ECS components and systems.     - </p> <p>src</p> <p>: Source files for ECS components and systems.   - <code>Modules/</code>: Contains modules for audio and graphics.     - <code>Audio/</code>: Audio management.       - <code>include/</code>: Header files for audio management.       - </p> <p>src</p> <p>: Source files for audio management.     - <code>Graphics/</code>: Graphics management.       - <code>include/</code>: Header files for graphics management.       - </p> <p>src</p> <p>: Source files for graphics management.   - <code>Network/</code>: Network communication implementation.   - <code>RType/</code>: Game-specific logic and systems.     - <code>include/</code>: Header files for game logic and systems.     - </p> <p>src</p> <p>: Source files for game logic and systems.   - <code>Tests/</code>: Unit tests for the project.   - <code>Utils/</code>: Utility files.</p>"},{"location":"architecture/#components","title":"Components","text":"<p>Components are data structures that hold the state of entities. They are stored in sparse arrays within the </p> <p>Registry</p> <p>.</p>"},{"location":"architecture/#position","title":"Position","text":"<pre><code>struct Position {\n    float x, y;\n    Position() = default;\n    Position(float posX, float posY) : x(posX), y(posY) {}\n};\n</code></pre>"},{"location":"architecture/#velocity","title":"Velocity","text":"<pre><code>struct Velocity {\n    float vx = 0.0f;\n    float vy = 0.0f;\n    Velocity() = default;\n    Velocity(float vx, float vy) : vx(vx), vy(vy) {}\n};\n</code></pre>"},{"location":"architecture/#drawable","title":"Drawable","text":"<pre><code>struct Drawable {};\n</code></pre>"},{"location":"architecture/#inputcomponent","title":"InputComponent","text":"<pre><code>struct InputComponent {\n    bool right = false;\n    bool left = false;\n    bool up = false;\n    bool down = false;\n};\n</code></pre>"},{"location":"architecture/#projectile","title":"Projectile","text":"<pre><code>struct Projectile {\n    bool is_player_projectile;\n    Projectile(bool is_player_projectile) : is_player_projectile(is_player_projectile) {}\n};\n</code></pre>"},{"location":"architecture/#enemy","title":"Enemy","text":"<pre><code>struct Enemy {\n    float speed;\n    Enemy(float speed) : speed(speed) {}\n};\n</code></pre>"},{"location":"architecture/#colorcomponent","title":"ColorComponent","text":"<pre><code>struct ColorComponent {\n    float r, g, b, a;\n    ColorComponent() = default;\n    ColorComponent(float r, float g, float b, float a) : r(r), g(g), b(b), a(a) {}\n};\n</code></pre>"},{"location":"architecture/#hitbox","title":"Hitbox","text":"<pre><code>struct Hitbox {\n    float width;\n    float height;\n    Hitbox(float width = 1.0f, float height = 1.0f) : width(width), height(height) {}\n};\n</code></pre>"},{"location":"architecture/#entitytype","title":"EntityType","text":"<pre><code>enum class EntityType {\n    PLAYER,\n    PROJECTILE,\n    ENEMY\n};\n</code></pre>"},{"location":"architecture/#entitytypecomponent","title":"EntityTypeComponent","text":"<pre><code>struct EntityTypeComponent {\n    EntityType type;\n    EntityTypeComponent(EntityType type) : type(type) {}\n};\n</code></pre>"},{"location":"architecture/#systems","title":"Systems","text":"<p>Systems are responsible for updating entities based on their components.</p>"},{"location":"architecture/#movementsystem","title":"MovementSystem","text":"<pre><code>class MovementSystem : public SystemBase {\npublic:\n    MovementSystem(Registry&amp; registry) : _registry(registry) {}\n    void update(float delta_time) override;\nprivate:\n    Registry&amp; _registry;\n};\n</code></pre>"},{"location":"architecture/#inputsystem","title":"InputSystem","text":"<pre><code>class InputSystem : public SystemBase {\npublic:\n    InputSystem(Registry &amp;registry, GameNetwork &amp;network, AudioManager &amp;audioManager);\n    void update(float delta_time) override;\nprivate:\n    Registry &amp;_registry;\n    GameNetwork &amp;_network;\n    AudioManager &amp;_audioManager;\n};\n</code></pre>"},{"location":"architecture/#shootingsystem","title":"ShootingSystem","text":"<pre><code>class ShootingSystem : public SystemBase {\npublic:\n    ShootingSystem(Registry&amp; registry) : _registry(registry) {}\n    void update(float delta_time) override;\nprivate:\n    Registry&amp; _registry;\n};\n</code></pre>"},{"location":"architecture/#enemyspawnsystem","title":"EnemySpawnSystem","text":"<pre><code>class EnemySpawnSystem : public SystemBase {\npublic:\n    EnemySpawnSystem(Registry&amp; registry);\n    void update(float delta_time) override;\n    void spawn_enemy_from_server(uint32_t enemyId, float x, float y);\nprivate:\n    Registry&amp; _registry;\n    float spawn_timer;\n    float spawn_interval;\n    float enemy_speed;\n};\n</code></pre>"},{"location":"architecture/#enemyshootingsystem","title":"EnemyShootingSystem","text":"<pre><code>class EnemyShootingSystem : public SystemBase {\npublic:\n    EnemyShootingSystem(Registry &amp;registry);\n    void update(float delta_time) override;\nprivate:\n    Registry &amp;_registry;\n    float shoot_timer;\n    float shoot_interval;\n    void shoot_projectiles();\n};\n</code></pre>"},{"location":"architecture/#collisionsystem","title":"CollisionSystem","text":"<pre><code>class CollisionSystem : public SystemBase {\npublic:\n    CollisionSystem(Registry &amp;registry, AudioManager &amp;audioManager);\n    void update(float delta_time) override;\nprivate:\n    Registry &amp;_registry;\n    AudioManager _audioManager;\n    bool check_collision(const Position &amp;posA, const Hitbox &amp;boxA, const Position &amp;posB, const Hitbox &amp;boxB);\n    void handle_collision(size_t entityA, size_t entityB);\n    void handle_player_hit(size_t player_index);\n};\n</code></pre>"},{"location":"architecture/#managers","title":"Managers","text":"<p>Managers handle specific aspects of the game, such as audio and graphics.</p>"},{"location":"architecture/#audiomanager","title":"AudioManager","text":"<pre><code>class AudioManager {\npublic:\n    AudioManager();\n    static Sound&amp; loadSound(const std::string&amp; id, const std::string&amp; filepath);\n    static Sound&amp; getSound(const std::string&amp; id);\n    static void playSound(const std::string&amp; id);\n    static bool isSoundLoaded(const std::string&amp; id);\n    ~AudioManager();\nprivate:\n    static std::unordered_map&lt;std::string, Sound&gt; sounds;\n};\n</code></pre>"},{"location":"architecture/#graphicsmanager","title":"GraphicsManager","text":"<pre><code>class GraphicsManager {\npublic:\n    GraphicsManager();\n    static Texture2D&amp; loadTexture(const std::string&amp; id, const std::string&amp; filepath);\n    static Texture2D&amp; getTexture(const std::string&amp; id);\n    static void loadGifAsSpriteSheet(const std::string&amp; id, const std::string&amp; filepath, int rows, int cols);\n    static Texture2D&amp; getGifFrame(const std::string&amp; id, int frameIndex);\n    static bool isTextureLoaded(const std::string&amp; id);\n    static bool isGifLoaded(const std::string&amp; id);\n    ~GraphicsManager();\nprivate:\n    static std::unordered_map&lt;std::string, Texture2D&gt; textures;\n    static std::unordered_map&lt;std::string, std::vector&lt;Texture2D&gt;&gt; gifs;\n};\n</code></pre>"},{"location":"architecture/#network","title":"Network","text":"<p>The network module handles communication between the client and server.</p>"},{"location":"architecture/#gamenetwork","title":"GameNetwork","text":"<pre><code>class GameNetwork {\npublic:\n    GameNetwork(asio::io_context&amp; io_context, const std::string&amp; serverIP, int serverPort, int udpPort, ECS::Registry &amp;registry);\n    ~GameNetwork();\n    void sendConnectMessage(const std::string&amp; username);\n    uint32_t receivePlayerID();\n    void sendDisconnectMessage();\n    void sendMoveMessage(float posX, float posY);\n    void start_send();\n    void start_receive();\n    std::function&lt;void(uint32_t enemyId, float x, float y)&gt; notifyEnemySpawn;\n    void handleSpawnEnemyMessage(const char* buffer);\nprivate:\n    int tcpSocket;\n    int udpServPort;\n    sockaddr_in serverAddr;\n    asio::ip::udp::socket udpSocket;\n    asio::ip::udp::endpoint server_endpoint_;\n    std::string message_;\n    enum { max_length = 1024 };\n    char data_[max_length];\n    ECS::Registry&amp; registry;\n    std::unordered_map&lt;uint32_t, ECS::Entity&gt; playerIdMap;\npublic:\n    uint32_t playerId;\n};\n</code></pre>"},{"location":"architecture/#server","title":"Server","text":"<pre><code>class Server {\npublic:\n    Server(asio::io_context&amp; io_context, const std::string&amp; serverIP, int udpPort);\n    ~Server();\n    void start_receive();\n    void run(asio::io_context&amp; io_context);\n    void handleClient(int clientSocket);\n    void handleMessage(uint8_t messageType, const char *buffer, size_t bytesRead, int socket, const sockaddr_in *udpClientAddr, asio::ip::udp::endpoint serverEndpoint);\n    void handleUDPMessages();\n    void broadcastBinaryMessage(uint8_t messageType, uint32_t playerId, float posX, float posY, uint8_t state);\n    void handleConnect(int clientSocket, const char *buffer);\n    void handleDisconnect(uint32_t playerId);\n    void handleMoveMessage(const char* buffer);\n    void handleShootMessage(const char *buffer);\n    void sendBinaryMessage(int clientSocket, uint8_t messageType, const void *data, size_t dataSize);\n    void spawnEnemy();\n    void enemySpawnLoop();\nprivate:\n    int playerCounter;\n    int enemyCounter;\n    int udpServPort;\n    asio::ip::udp::socket udpSocket;\n    std::unordered_map&lt;uint32_t, Player&gt; players;\n    std::unordered_map&lt;uint32_t, asio::ip::udp::endpoint&gt; senderEndpoints;\n    bool stopServer;\n};\n</code></pre>"},{"location":"architecture/#client","title":"Client","text":"<pre><code>class Client {\npublic:\n    Client(const std::string &amp;serverAddress, int serverPort);\n    ~Client();\n    void connectToServer();\n    void sendConnectRequest(const std::string &amp;username);\n    void receiveResponse();\nprivate:\n    std::string serverAddress;\n    int serverPort;\n    int tcpSocket;\n};\n</code></pre>"},{"location":"architecture/#utilities","title":"Utilities","text":"<p>Utility files provide additional functionality used throughout the project.</p>"},{"location":"architecture/#timer","title":"Timer","text":"<pre><code>#ifndef TIMER_HPP_\n#define TIMER_HPP_\n#endif /* !TIMER_HPP_ */\n</code></pre>"},{"location":"architecture/#logger","title":"Logger","text":"<pre><code>#ifndef LOGGER_HPP_\n#define LOGGER_HPP_\n#endif /* !LOGGER_HPP_ */\n</code></pre>"},{"location":"architecture/#config","title":"Config","text":"<pre><code>#ifndef CONFIG_HPP_\n#define CONFIG_HPP_\n#endif /* !CONFIG_HPP_ */\n</code></pre>"},{"location":"architecture/#main-files","title":"Main Files","text":"<p>The main files initialize and run the game.</p>"},{"location":"architecture/#main-client","title":"Main Client","text":"<pre><code>int main() {\n    std::string serverAddress = \"127.0.0.1\";\n    int serverPort = 4242;\n    rtype::Client client(serverAddress, serverPort);\n    client.connectToServer();\n    client.sendConnectRequest(\"Player1\");\n    client.receiveResponse();\n    return 0;\n}\n</code></pre>"},{"location":"architecture/#main-server","title":"Main Server","text":"<pre><code>int main() {\n    try {\n        std::signal(SIGINT, signalHandler); \n        std::signal(SIGTERM, signalHandler);\n        asio::io_context io_context;\n        rtype::Server server(io_context, \"127.0.0.1\", 4343);\n        std::cout &lt;&lt; \"[Rtype SERVER]: starting the server\" &lt;&lt; std::endl;\n        std::thread serverThread([&amp;server, &amp;io_context]() {\n            try {\n                server.run(io_context);\n            } catch (const std::exception &amp;ex) {\n                std::cerr &lt;&lt; \"[Rtype SERVER]: server error ...\" &lt;&lt; ex.what() &lt;&lt; std::endl;\n                running = false;\n            }\n        });\n        while (running) {\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n        }\n        std::cout &lt;&lt; \"[Rtype SERVER]: Shutting down ...\" &lt;&lt; std::endl;\n        if (serverThread.joinable()) {\n            serverThread.detach();\n        }\n        std::cout &lt;&lt; \"[Rtype SERVER]: Server stopped gracefully\" &lt;&lt; std::endl;\n        return EXIT_SUCCESS;\n    } catch(const rtype::Exception &amp;ex) {\n        std::cerr &lt;&lt; \"[Rtype SERVER]: Exception found\" &lt;&lt; ex.what() &lt;&lt; std::endl;\n        return EXIT_FAILURE;\n    } catch (const std::exception &amp;ex) {\n        std::cerr &lt;&lt; \"Fatal error: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n        return EXIT_FAILURE;\n    } catch (...) {\n        std::cerr &lt;&lt; \"Unknown fatal error\" &lt;&lt; std::endl;\n        return EXIT_FAILURE;\n    }\n}\n</code></pre>"},{"location":"architecture/#main-game","title":"Main Game","text":"<p>```cpp int main() {     const int screenWidth = 800;     const int screenHeight = 600;     InitWindow(screenWidth, screenHeight, \"R-Type Standalone\");     InitAudioDevice();</p> <pre><code>AudioManager audioManager;\naudioManager.loadSound(\"shoot\", \"../assets/sounds/laser.mp3\");\naudioManager.loadSound(\"game_over\", \"../assets/sounds/game_over.mp3\");\naudioManager.loadSound(\"explosion\", \"../assets/sounds/explosion.mp3\");\n\nGraphicsManager graphicsManager;\ngraphicsManager.loadTexture(\"player\", \"../assets/sprites/player1.png\");\ngraphicsManager.loadGifAsSpriteSheet(\"laser\", \"../assets/sprites/laser.gif\", 1, 2);\ngraphicsManager.loadGifAsSpriteSheet(\"enemyLaser\", \"../assets/sprites/enemyLaser.gif\", 1, 2);\ngraphicsManager.loadGifAsSpriteSheet(\"power\", \"../assets/sprites/power.gif\", 1, 4);\ngraphicsManager.loadGifAsSpriteSheet(\"enemy1\", \"../assets/sprites/enemy1.gif\", 1, 3);\n\nGameState state = GameState::MENU;\nECS::Registry registry;\nECS::SystemManager systemManager;\nasio::io_context io_context;\nGameNetwork network(io_context, \"127.0.0.1\", 4242, 4343, registry);\n\nstd::string username = \"Player1\";\nnetwork.sendConnectMessage(username);\nnetwork.playerId = network.receivePlayerID();\nstd::cout &lt;&lt; \"[Game] Connected with Player ID: \" &lt;&lt; network.playerId &lt;&lt; \"\\n\";\n\nnetwork.notifyEnemySpawn = [&amp;](uint32_t enemyId, float x, float y) {\n    GameSetup::spawnEnemy(registry, x, y);\n};\n\nGameSetup::initializeECS(registry, systemManager, network, audioManager, graphicsManager);\nstd::thread ioThread([&amp;io_context]() {\n    io_context.run();\n});\n\nwhile (state != GameState::EXIT &amp;&amp; !WindowShouldClose()) {\n    if (state == GameState::MENU) {\n        show_menu(state);\n    } else if (state == GameState::SETTINGS) {\n        show_settings(state);\n    } else if (state == GameState::PLAYING) {\n        systemManager.update_all(GetFrameTime());\n        BeginDrawing();\n        ClearBackground(RAYWHITE);\n        systemManager.render_all();\n        EndDrawing();\n    }\n}\n\nCloseAudioDevice();\nCloseWindow();\nreturn 0;\n</code></pre> <p>}</p>"},{"location":"dev/ECS/APIReference/","title":"API Reference","text":"<p>This section provides detailed documentation for the classes and methods used in the ECS architecture.</p>"},{"location":"dev/ECS/APIReference/#sparsearray","title":"SparseArray","text":""},{"location":"dev/ECS/APIReference/#class-definition","title":"Class Definition","text":"<pre><code>template &lt;typename Component&gt;\nclass SparseArray {\npublic:\n    using value_type = std::optional&lt;Component&gt;;\n    using reference_type = value_type&amp;;\n\n    reference_type operator[](size_t idx);\n    reference_type insert_at(size_t pos, const Component&amp; component);\n    void erase(size_t pos);\n    size_t size() const;\n};\n</code></pre>"},{"location":"dev/ECS/APIReference/#methods","title":"Methods","text":"<ul> <li><code>operator[](size_t idx)</code></li> <li>Description: Access or create a component at the specified index.</li> <li>Parameters:<ul> <li><code>size_t idx</code>: Index of the component.</li> </ul> </li> <li> <p>Returns: Reference to the optional component.</p> </li> <li> <p><code>insert_at(size_t pos, const Component&amp;)</code></p> </li> <li>Description: Insert a component at the specified position, resizing if necessary.</li> <li>Parameters:<ul> <li><code>size_t pos</code>: Position to insert the component.</li> <li><code>const Component&amp;</code>: The component to insert.</li> </ul> </li> <li> <p>Returns: Reference to the inserted component.</p> </li> <li> <p><code>erase(size_t pos)</code></p> </li> <li>Description: Removes the component at the specified position.</li> <li> <p>Parameters:</p> <ul> <li><code>size_t pos</code>: Position of the component to erase.</li> </ul> </li> <li> <p><code>size() const</code></p> </li> <li>Description: Returns the number of elements in the sparse array.</li> <li>Returns: The size of the sparse array.</li> </ul>"},{"location":"dev/ECS/APIReference/#registry","title":"Registry","text":""},{"location":"dev/ECS/APIReference/#class-definition_1","title":"Class Definition","text":"<pre><code>class Registry {\npublic:\n    template &lt;typename Component&gt;\n    SparseArray&lt;Component&gt;&amp; get_components();\n\n    template &lt;typename Component&gt;\n    void add_component(size_t entity, Component component);\n\n    template &lt;typename Component&gt;\n    void remove_component(size_t entity);\n};\n</code></pre>"},{"location":"dev/ECS/APIReference/#methods_1","title":"Methods","text":"<ul> <li><code>get_components&lt;Component&gt;()</code></li> <li>Description: Retrieve the <code>SparseArray</code> for a specific component type.</li> <li> <p>Returns: Reference to the <code>SparseArray</code> of the specified component type.</p> </li> <li> <p><code>add_component&lt;Component&gt;(size_t entity, Component component)</code></p> </li> <li>Description: Attaches a component to the given entity.</li> <li> <p>Parameters:</p> <ul> <li><code>size_t entity</code>: The entity ID.</li> <li><code>Component component</code>: The component to attach.</li> </ul> </li> <li> <p><code>remove_component&lt;Component&gt;(size_t entity)</code></p> </li> <li>Description: Detaches a component from the specified entity.</li> <li>Parameters:<ul> <li><code>size_t entity</code>: The entity ID.</li> </ul> </li> </ul>"},{"location":"dev/ECS/APIReference/#systemmanager","title":"SystemManager","text":""},{"location":"dev/ECS/APIReference/#class-definition_2","title":"Class Definition","text":"<pre><code>class SystemManager {\npublic:\n    void add_system(std::shared_ptr&lt;SystemBase&gt; system, int priority = 0);\n    void update_all(float delta_time);\n    void render_all();\n};\n</code></pre>"},{"location":"dev/ECS/APIReference/#methods_2","title":"Methods","text":"<ul> <li><code>add_system(std::shared_ptr&lt;SystemBase&gt; system, int priority)</code></li> <li>Description: Adds a system to the manager with a specified priority.</li> <li> <p>Parameters:</p> <ul> <li><code>std::shared_ptr&lt;SystemBase&gt; system</code>: The system to add.</li> <li><code>int priority</code>: Priority value for execution order (lower executes first).</li> </ul> </li> <li> <p><code>update_all(float delta_time)</code></p> </li> <li>Description: Calls the <code>update</code> method of all registered systems in priority order.</li> <li> <p>Parameters:</p> <ul> <li><code>float delta_time</code>: Time elapsed since the last update.</li> </ul> </li> <li> <p><code>render_all()</code></p> </li> <li>Description: Invokes the <code>render</code> method of all rendering systems.</li> </ul>"},{"location":"dev/ECS/APIReference/#eventmanager","title":"EventManager","text":""},{"location":"dev/ECS/APIReference/#class-definition_3","title":"Class Definition","text":"<pre><code>class EventManager {\npublic:\n    void add_event(const Event&amp; event);\n    std::vector&lt;Event&gt; get_events(Event::EventType type);\n    void clear_events();\n};\n</code></pre>"},{"location":"dev/ECS/APIReference/#methods_3","title":"Methods","text":"<ul> <li><code>add_event(const Event&amp; event)</code></li> <li>Description: Adds an event to the queue.</li> <li> <p>Parameters:</p> <ul> <li><code>const Event&amp; event</code>: The event to add.</li> </ul> </li> <li> <p><code>get_events(Event::EventType type)</code></p> </li> <li>Description: Retrieves all events of a specific type.</li> <li>Parameters:<ul> <li><code>Event::EventType type</code>: The type of event to retrieve.</li> </ul> </li> <li> <p>Returns: A vector of events of the specified type.</p> </li> <li> <p><code>clear_events()</code></p> </li> <li>Description: Clears all events from the queue.</li> </ul>"},{"location":"dev/ECS/APIReference/#renderingsystembase","title":"RenderingSystemBase","text":""},{"location":"dev/ECS/APIReference/#class-definition_4","title":"Class Definition","text":"<pre><code>class RenderingSystemBase : public SystemBase {\npublic:\n    virtual void render() = 0;\n    virtual ~RenderingSystemBase() = default;\n};\n</code></pre>"},{"location":"dev/ECS/APIReference/#methods_4","title":"Methods","text":"<ul> <li><code>render()</code></li> <li>Description: Pure virtual method to render entities and visuals.</li> <li>Returns: None.</li> </ul>"},{"location":"dev/ECS/APIReference/#file-references","title":"File References","text":"<ul> <li>Overview: Introduction to the ECS architecture.</li> <li>Core Components: Building blocks like <code>SparseArray</code> and <code>Registry</code>.</li> <li>Systems: Functional systems operating on entities.</li> <li>Event Management: Decoupled event-driven logic.</li> <li>System Manager: Orchestrating and rendering systems.</li> <li>Schemas and Diagrams: Visual representations.</li> </ul>"},{"location":"dev/ECS/APIReference/#next-steps","title":"Next Steps","text":"<p>For practical implementation examples, proceed to Examples.</p>"},{"location":"dev/ECS/CoreComponents/","title":"Core Components","text":"<p>This section details the core building blocks of the ECS architecture, specifically focusing on <code>SparseArray</code> and <code>Registry</code>.</p>"},{"location":"dev/ECS/CoreComponents/#sparsearray","title":"SparseArray","text":"<p>The <code>SparseArray</code> is a core data structure that provides efficient storage and retrieval of components.</p>"},{"location":"dev/ECS/CoreComponents/#overview","title":"Overview","text":"<p>The <code>SparseArray</code> class stores components in an optional manner, allowing: - Dynamic resizing. - Efficient indexing and retrieval. - Memory optimization by only allocating space when necessary.</p>"},{"location":"dev/ECS/CoreComponents/#key-features","title":"Key Features","text":"<ul> <li>Dynamic Growth: Automatically resizes when accessing out-of-bounds indices.</li> <li>Optional Storage: Components are wrapped in <code>std::optional</code>, ensuring memory is only allocated when needed.</li> <li>Type Safety: Templated to ensure components are strongly typed.</li> </ul>"},{"location":"dev/ECS/CoreComponents/#implementation-details","title":"Implementation Details","text":"<pre><code>template &lt;typename Component&gt;\nclass SparseArray {\npublic:\n    using value_type = std::optional&lt;Component&gt;;\n    using reference_type = value_type&amp;;\n\n    reference_type operator[](size_t idx);\n    reference_type insert_at(size_t pos, const Component&amp; component);\n    void erase(size_t pos);\n};\n</code></pre>"},{"location":"dev/ECS/CoreComponents/#methods","title":"Methods","text":"<ul> <li><code>operator[](size_t idx)</code></li> <li>Access or create a component at the specified index.</li> <li><code>insert_at(size_t pos, const Component&amp;)</code></li> <li>Inserts a component at the given position, resizing if necessary.</li> <li><code>erase(size_t pos)</code></li> <li>Removes the component at the specified position.</li> </ul>"},{"location":"dev/ECS/CoreComponents/#registry","title":"Registry","text":"<p>The <code>Registry</code> serves as the central manager for entities and their components.</p>"},{"location":"dev/ECS/CoreComponents/#overview_1","title":"Overview","text":"<p>The <code>Registry</code> is responsible for: - Creating and destroying entities. - Managing components associated with entities. - Providing access to component arrays for systems to operate on.</p>"},{"location":"dev/ECS/CoreComponents/#key-features_1","title":"Key Features","text":"<ul> <li>Entity Management: Each entity is represented by a unique identifier.</li> <li>Component Association: Maps entities to components using <code>SparseArray</code>.</li> <li>System Compatibility: Facilitates interaction between systems and components.</li> </ul>"},{"location":"dev/ECS/CoreComponents/#implementation-details_1","title":"Implementation Details","text":"<pre><code>class Registry {\npublic:\n    template &lt;typename Component&gt;\n    SparseArray&lt;Component&gt;&amp; get_components();\n\n    template &lt;typename Component&gt;\n    void add_component(size_t entity, Component component);\n\n    template &lt;typename Component&gt;\n    void remove_component(size_t entity);\n};\n</code></pre>"},{"location":"dev/ECS/CoreComponents/#methods_1","title":"Methods","text":"<ul> <li><code>get_components&lt;Component&gt;()</code></li> <li>Returns the <code>SparseArray</code> for the specified component type.</li> <li><code>add_component&lt;Component&gt;(size_t entity, Component component)</code></li> <li>Attaches a component to the given entity.</li> <li><code>remove_component&lt;Component&gt;(size_t entity)</code></li> <li>Detaches the component from the specified entity.</li> </ul>"},{"location":"dev/ECS/CoreComponents/#relationships","title":"Relationships","text":""},{"location":"dev/ECS/CoreComponents/#diagram","title":"Diagram","text":"<pre><code>[Registry]\n    |\n    +---&gt; [SparseArray&lt;Component&gt;]\n    |          +---&gt; [Components]\n    +---&gt; [SparseArray&lt;Component&gt;]\n               +---&gt; [Components]\n</code></pre> <p>The <code>Registry</code> maintains multiple <code>SparseArray</code> instances, one for each component type.</p>"},{"location":"dev/ECS/CoreComponents/#file-references","title":"File References","text":"<ul> <li>Systems: Explore how systems use components managed by <code>SparseArray</code> and <code>Registry</code>.</li> <li>API Reference: Detailed documentation of <code>SparseArray</code> and <code>Registry</code> methods.</li> </ul>"},{"location":"dev/ECS/CoreComponents/#next-steps","title":"Next Steps","text":"<p>Proceed to Systems to understand how logic is applied to entities using the components managed by <code>SparseArray</code> and <code>Registry</code>.</p>"},{"location":"dev/ECS/EventManagement/","title":"Event Management","text":"<p>Event management in the ECS architecture facilitates communication between systems and entities, enabling dynamic and decoupled game logic.</p>"},{"location":"dev/ECS/EventManagement/#overview","title":"Overview","text":"<p>Events represent actions or occurrences in the game, such as: - User Input: Key presses or mouse clicks. - Collisions: Two entities overlapping. - Timers: Actions triggered after a set duration.</p>"},{"location":"dev/ECS/EventManagement/#key-components","title":"Key Components","text":"<ol> <li>Event: Represents a single instance of an event.</li> <li>EventManager: Handles the registration, dispatch, and processing of events.</li> </ol>"},{"location":"dev/ECS/EventManagement/#event-class","title":"Event Class","text":"<p>The <code>Event</code> class encapsulates the details of an event.</p>"},{"location":"dev/ECS/EventManagement/#implementation","title":"Implementation","text":"<pre><code>class Event {\npublic:\n    enum EventType {\n        COLLISION,\n        KEY_PRESS,\n        TIMER_EXPIRED\n    };\n\n    EventType type;\n    size_t entity_id;\n    size_t other_entity_id;\n\n    Event(EventType type, size_t entity_id, size_t other_entity_id = 0)\n        : type(type), entity_id(entity_id), other_entity_id(other_entity_id) {}\n};\n</code></pre>"},{"location":"dev/ECS/EventManagement/#explanation","title":"Explanation","text":"<ul> <li><code>type</code>: Indicates the kind of event (e.g., collision).</li> <li><code>entity_id</code>: The entity associated with the event.</li> <li><code>other_entity_id</code>: An optional second entity, used for events like collisions.</li> </ul>"},{"location":"dev/ECS/EventManagement/#eventmanager","title":"EventManager","text":"<p>The <code>EventManager</code> class oversees the lifecycle of events.</p>"},{"location":"dev/ECS/EventManagement/#implementation_1","title":"Implementation","text":"<pre><code>class EventManager {\npublic:\n    void add_event(const Event&amp; event);\n    std::vector&lt;Event&gt; get_events(Event::EventType type);\n    void clear_events();\n\nprivate:\n    std::vector&lt;Event&gt; events;\n};\n</code></pre>"},{"location":"dev/ECS/EventManagement/#methods","title":"Methods","text":"<ul> <li><code>add_event(const Event&amp; event)</code></li> <li>Adds a new event to the queue.</li> <li><code>get_events(Event::EventType type)</code></li> <li>Retrieves all events of a specific type.</li> <li><code>clear_events()</code></li> <li>Clears the event queue, usually after processing.</li> </ul>"},{"location":"dev/ECS/EventManagement/#event-flow","title":"Event Flow","text":""},{"location":"dev/ECS/EventManagement/#workflow","title":"Workflow","text":"<ol> <li>Event Creation: A system or input handler generates an event.</li> <li>Event Dispatch: The <code>EventManager</code> queues the event.</li> <li>Event Processing: Relevant systems retrieve and handle events.</li> </ol>"},{"location":"dev/ECS/EventManagement/#example","title":"Example","text":""},{"location":"dev/ECS/EventManagement/#collision-event","title":"Collision Event","text":"<ol> <li>Creation: The Physics System detects a collision and generates a <code>COLLISION</code> event.</li> <li>Dispatch: The event is added to the <code>EventManager</code>.</li> <li>Processing:</li> <li>The rendering system might display a visual effect.</li> <li>The game logic system might reduce health or destroy an entity.</li> </ol>"},{"location":"dev/ECS/EventManagement/#diagram","title":"Diagram","text":"<pre><code>[System/Handler] ---&gt; [EventManager]\n        |                    |\n        +--- Generates        +--- Dispatches\n             Events                 Events\n                                 |\n                            [Processing Systems]\n</code></pre>"},{"location":"dev/ECS/EventManagement/#file-references","title":"File References","text":"<ul> <li>Systems: Explore how systems interact with events.</li> <li>Core Components: Key structures that work with events.</li> </ul>"},{"location":"dev/ECS/EventManagement/#next-steps","title":"Next Steps","text":"<p>Proceed to System Manager for details on orchestrating systems and integrating event-driven logic.</p>"},{"location":"dev/ECS/Examples/","title":"Examples and Enhancements","text":"<p>This section provides practical examples of ECS usage and suggests potential enhancements to improve functionality and scalability.</p>"},{"location":"dev/ECS/Examples/#examples","title":"Examples","text":""},{"location":"dev/ECS/Examples/#1-creating-an-entity-with-components","title":"1. Creating an Entity with Components","text":"<p>This example demonstrates how to create an entity and attach components to it.</p> <pre><code>#include \"Registry.hpp\"\n#include \"Component.hpp\"\n\nint main() {\n    ECS::Registry registry;\n\n    // Create an entity\n    size_t player = registry.create_entity();\n\n    // Add components\n    registry.add_component&lt;Position&gt;(player, {0.0f, 0.0f});\n    registry.add_component&lt;Velocity&gt;(player, {5.0f, 0.0f});\n\n    return 0;\n}\n</code></pre>"},{"location":"dev/ECS/Examples/#2-updating-systems","title":"2. Updating Systems","text":"<p>Here\u2019s how to update all systems within the <code>SystemManager</code>.</p> <pre><code>#include \"SystemManager.hpp\"\n#include \"MovementSystem.hpp\"\n\nint main() {\n    ECS::SystemManager manager;\n    ECS::Registry registry;\n\n    // Add a movement system\n    manager.add_system(std::make_shared&lt;ECS::MovementSystem&gt;());\n\n    // Game loop\n    while (true) {\n        float delta_time = 0.016f; // Example delta time (60 FPS)\n        manager.update_all(delta_time);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"dev/ECS/Examples/#3-event-handling","title":"3. Event Handling","text":"<p>Example of generating and processing collision events.</p> <pre><code>#include \"EventManager.hpp\"\n#include \"Event.hpp\"\n\nint main() {\n    ECS::EventManager event_manager;\n\n    // Generate a collision event\n    event_manager.add_event(ECS::Event(ECS::Event::COLLISION, 1, 2));\n\n    // Retrieve and process events\n    auto collision_events = event_manager.get_events(ECS::Event::COLLISION);\n    for (const auto&amp; event : collision_events) {\n        std::cout &lt;&lt; \"Collision detected between entities \"\n                  &lt;&lt; event.entity_id &lt;&lt; \" and \" &lt;&lt; event.other_entity_id &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"dev/ECS/Examples/#suggested-enhancements","title":"Suggested Enhancements","text":""},{"location":"dev/ECS/Examples/#1-advanced-event-system","title":"1. Advanced Event System","text":"<ul> <li>Enhancement: Introduce event listeners and subscriptions.</li> <li>Benefits: Enables more granular event handling and system notifications.</li> </ul>"},{"location":"dev/ECS/Examples/#2-threaded-systems","title":"2. Threaded Systems","text":"<ul> <li>Enhancement: Enable systems to run on separate threads for performance gains.</li> <li>Challenges: Requires careful synchronization of shared resources.</li> </ul>"},{"location":"dev/ECS/Examples/#3-debugging-tools","title":"3. Debugging Tools","text":"<ul> <li>Enhancement: Add visualization tools for entities, components, and systems.</li> <li>Benefits: Simplifies debugging and improves developer experience.</li> </ul>"},{"location":"dev/ECS/Examples/#4-expanded-component-types","title":"4. Expanded Component Types","text":"<ul> <li>Enhancement: Include components for animations, sound, and AI behaviors.</li> <li>Benefits: Broadens the range of supported game mechanics.</li> </ul>"},{"location":"dev/ECS/Examples/#file-references","title":"File References","text":"<ul> <li>Overview: Introduction to the ECS architecture.</li> <li>Core Components: Details on <code>SparseArray</code> and <code>Registry</code>.</li> <li>Systems: Functional systems operating on entities.</li> <li>API Reference: Detailed documentation of ECS methods.</li> <li>Schemas and Diagrams: Visual representations.</li> </ul>"},{"location":"dev/ECS/Examples/#next-steps","title":"Next Steps","text":"<p>This concludes the ECS documentation. You are now equipped to develop, extend, and maintain an efficient ECS-based architecture.</p>"},{"location":"dev/ECS/Overview/","title":"ECS Overview and Introduction","text":""},{"location":"dev/ECS/Overview/#what-is-ecs","title":"What is ECS?","text":"<p>The Entity Component System (ECS) is a design pattern that decouples game logic into three fundamental parts:</p> <ol> <li>Entity: A unique identifier representing an object in the game world.</li> <li>Component: A container for data that defines the state or behavior of an entity.</li> <li>System: Logic that processes entities possessing specific components.</li> </ol> <p>This separation of concerns ensures modularity, flexibility, and performance.</p>"},{"location":"dev/ECS/Overview/#why-use-ecs","title":"Why Use ECS?","text":"<p>ECS is favored for game development due to:</p> <ul> <li>Modularity: Adding new functionality becomes straightforward without affecting existing systems.</li> <li>Performance: Efficiently processes large numbers of entities.</li> <li>Flexibility: Systems can operate independently, making it easier to adapt to changing requirements.</li> </ul>"},{"location":"dev/ECS/Overview/#ecs-in-r-type","title":"ECS in R-Type","text":"<p>In the R-Type project, ECS facilitates:</p> <ul> <li>Clear separation of data (components) and logic (systems).</li> <li>Efficient management of entities like players, enemies, and projectiles.</li> <li>Scalable design for adding new features or mechanics.</li> </ul>"},{"location":"dev/ECS/Overview/#high-level-workflow","title":"High-Level Workflow","text":"<ol> <li>Entities are created in the <code>Registry</code>.</li> <li>Components are attached to entities to define their state.</li> <li>Systems operate on entities with specific components, updating their state or triggering events.</li> </ol>"},{"location":"dev/ECS/Overview/#file-organization","title":"File Organization","text":"<ul> <li>Core Components: Details of <code>SparseArray</code>, <code>Registry</code>, and related utilities.</li> <li>Systems: Explanation of systems like Movement and Physics.</li> <li>Event Management: Handling game events.</li> <li>System Manager: Managing and prioritizing systems.</li> <li>Schemas and Diagrams: Visual representations of ECS structure.</li> <li>API Reference: Detailed class and method documentation.</li> <li>Examples: Practical use cases and future ideas.</li> </ul>"},{"location":"dev/ECS/Overview/#next-steps","title":"Next Steps","text":"<p>Refer to Core Components for a detailed understanding of the building blocks of this ECS architecture.</p>"},{"location":"dev/ECS/SchemasAndDiagrams/","title":"Schemas and Diagrams","text":"<p>This section provides visual representations of the ECS architecture and its components to facilitate a deeper understanding of their relationships and workflows.</p>"},{"location":"dev/ECS/SchemasAndDiagrams/#high-level-ecs-architecture","title":"High-Level ECS Architecture","text":""},{"location":"dev/ECS/SchemasAndDiagrams/#diagram","title":"Diagram","text":"<pre><code>[Entity]\n    |\n    +---&gt; [Components]\n    |\n    +---&gt; [Systems]\n          |\n          +---&gt; [Registry]\n                |\n                +---&gt; [SparseArray&lt;Component&gt;]\n</code></pre>"},{"location":"dev/ECS/SchemasAndDiagrams/#explanation","title":"Explanation","text":"<ul> <li>Entity: A unique identifier that links to components.</li> <li>Components: Data structures attached to entities.</li> <li>Systems: Operate on entities with specific components.</li> <li>Registry: Manages components using <code>SparseArray</code>.</li> </ul>"},{"location":"dev/ECS/SchemasAndDiagrams/#component-management-workflow","title":"Component Management Workflow","text":""},{"location":"dev/ECS/SchemasAndDiagrams/#diagram_1","title":"Diagram","text":"<pre><code>[Registry]\n    |\n    +---&gt; [SparseArray&lt;Position&gt;]\n    |          +---&gt; [Optional Components]\n    |\n    +---&gt; [SparseArray&lt;Velocity&gt;]\n               +---&gt; [Optional Components]\n</code></pre>"},{"location":"dev/ECS/SchemasAndDiagrams/#explanation_1","title":"Explanation","text":"<ol> <li>Registry: Maintains <code>SparseArray</code> instances for each component type.</li> <li>SparseArray: Provides efficient storage and retrieval for components.</li> <li>Optional Components: Ensure memory is only allocated when necessary.</li> </ol>"},{"location":"dev/ECS/SchemasAndDiagrams/#system-interaction","title":"System Interaction","text":""},{"location":"dev/ECS/SchemasAndDiagrams/#diagram_2","title":"Diagram","text":"<pre><code>[SystemManager]\n    |\n    +---&gt; [SystemBase]\n    |          +---&gt; [Specific Systems]\n    |\n    +---&gt; [RenderingSystemBase]\n               +---&gt; [Rendering Systems]\n</code></pre>"},{"location":"dev/ECS/SchemasAndDiagrams/#explanation_2","title":"Explanation","text":"<ul> <li>SystemManager: Oversees system execution and prioritization.</li> <li>SystemBase: Base class for all systems.</li> <li>RenderingSystemBase: Specialized base class for rendering systems.</li> <li>Specific Systems: Examples include MovementSystem, TimerSystem, and PhysicsSystem.</li> </ul>"},{"location":"dev/ECS/SchemasAndDiagrams/#event-flow","title":"Event Flow","text":""},{"location":"dev/ECS/SchemasAndDiagrams/#diagram_3","title":"Diagram","text":"<pre><code>[System/Handler] ---&gt; [EventManager]\n        |                    |\n        +--- Generates        +--- Dispatches\n             Events                 Events\n                                 |\n                            [Processing Systems]\n</code></pre>"},{"location":"dev/ECS/SchemasAndDiagrams/#explanation_3","title":"Explanation","text":"<ol> <li>Event Generation: Systems or input handlers create events.</li> <li>Event Dispatch: The <code>EventManager</code> queues and distributes events.</li> <li>Event Processing: Relevant systems handle dispatched events.</li> </ol>"},{"location":"dev/ECS/SchemasAndDiagrams/#file-references","title":"File References","text":"<ul> <li>Overview: Introduction to ECS.</li> <li>Core Components: Details on <code>SparseArray</code> and <code>Registry</code>.</li> <li>Systems: Explanation of system functionality.</li> <li>System Manager: Details on orchestrating system execution.</li> <li>Event Management: Integration of events into ECS workflows.</li> </ul>"},{"location":"dev/ECS/SchemasAndDiagrams/#next-steps","title":"Next Steps","text":"<p>Refer to API Reference for detailed documentation of classes and methods.</p>"},{"location":"dev/ECS/SystemManager/","title":"System Manager and Rendering","text":"<p>The System Manager orchestrates the execution of multiple systems, ensuring that they run in the correct order and priority. Rendering systems are specialized systems responsible for drawing entities and the game world.</p>"},{"location":"dev/ECS/SystemManager/#system-manager","title":"System Manager","text":""},{"location":"dev/ECS/SystemManager/#overview","title":"Overview","text":"<p>The <code>SystemManager</code> class organizes and manages the lifecycle of systems. It: - Supports dynamic addition and removal of systems. - Prioritizes systems based on their assigned priority values. - Updates and renders systems as required.</p>"},{"location":"dev/ECS/SystemManager/#implementation","title":"Implementation","text":"<pre><code>class SystemManager {\npublic:\n    void add_system(std::shared_ptr&lt;SystemBase&gt; system, int priority = 0);\n    void update_all(float delta_time);\n    void render_all();\n\nprivate:\n    std::vector&lt;std::pair&lt;int, std::shared_ptr&lt;SystemBase&gt;&gt;&gt; _systems;\n};\n</code></pre>"},{"location":"dev/ECS/SystemManager/#methods","title":"Methods","text":"<ul> <li><code>add_system(std::shared_ptr&lt;SystemBase&gt; system, int priority)</code></li> <li>Adds a system to the manager with a priority value.</li> <li> <p>Systems with lower priority values are executed first.</p> </li> <li> <p><code>update_all(float delta_time)</code></p> </li> <li> <p>Calls the <code>update</code> method of each system in priority order.</p> </li> <li> <p><code>render_all()</code></p> </li> <li>Calls the <code>render</code> method of rendering systems, ensuring they draw in the correct sequence.</li> </ul>"},{"location":"dev/ECS/SystemManager/#workflow","title":"Workflow","text":"<ol> <li>Systems are registered with the <code>SystemManager</code> using <code>add_system</code>.</li> <li>During each game loop iteration:</li> <li>Update Phase: All systems are updated via <code>update_all</code>.</li> <li>Render Phase: Rendering systems are invoked via <code>render_all</code>.</li> </ol>"},{"location":"dev/ECS/SystemManager/#rendering-system","title":"Rendering System","text":""},{"location":"dev/ECS/SystemManager/#overview_1","title":"Overview","text":"<p>Rendering systems specialize in drawing entities and their components. They inherit from <code>RenderingSystemBase</code>, extending it with specific rendering logic.</p>"},{"location":"dev/ECS/SystemManager/#base-class","title":"Base Class","text":"<pre><code>class RenderingSystemBase : public SystemBase {\npublic:\n    virtual void render() = 0;\n    virtual ~RenderingSystemBase() = default;\n};\n</code></pre>"},{"location":"dev/ECS/SystemManager/#example-simple-rendering-system","title":"Example: Simple Rendering System","text":"<pre><code>class SimpleRenderingSystem : public RenderingSystemBase {\npublic:\n    void update(float delta_time) override {\n        // Update logic, if needed\n    }\n\n    void render() override {\n        // Rendering logic, e.g., draw entities\n    }\n};\n</code></pre>"},{"location":"dev/ECS/SystemManager/#relationship-diagram","title":"Relationship Diagram","text":"<pre><code>[SystemManager]\n    |\n    +---&gt; [SystemBase]\n    |          +---&gt; [Specific Systems]\n    |\n    +---&gt; [RenderingSystemBase]\n               +---&gt; [Rendering Systems]\n</code></pre>"},{"location":"dev/ECS/SystemManager/#example-usage","title":"Example Usage","text":""},{"location":"dev/ECS/SystemManager/#registering-systems","title":"Registering Systems","text":"<pre><code>SystemManager manager;\nmanager.add_system(std::make_shared&lt;MovementSystem&gt;(), 1);\nmanager.add_system(std::make_shared&lt;SimpleRenderingSystem&gt;(), 0);\n</code></pre>"},{"location":"dev/ECS/SystemManager/#executing-systems","title":"Executing Systems","text":"<pre><code>manager.update_all(delta_time);\nmanager.render_all();\n</code></pre>"},{"location":"dev/ECS/SystemManager/#file-references","title":"File References","text":"<ul> <li>Systems: General details about system functionality.</li> <li>Event Management: Events that can trigger rendering or updates.</li> <li>Schemas and Diagrams: Additional visualizations of system architecture.</li> </ul>"},{"location":"dev/ECS/SystemManager/#next-steps","title":"Next Steps","text":"<p>Proceed to Schemas and Diagrams for visual representations of the ECS architecture and its components.</p>"},{"location":"dev/ECS/Systems/","title":"Systems","text":"<p>Systems in the ECS architecture define the logic that operates on entities with specific components. They encapsulate functionality, making the architecture modular and scalable.</p>"},{"location":"dev/ECS/Systems/#key-systems","title":"Key Systems","text":""},{"location":"dev/ECS/Systems/#1-movement-system","title":"1. Movement System","text":"<p>The Movement System updates the positions of entities based on their velocity components.</p>"},{"location":"dev/ECS/Systems/#purpose","title":"Purpose","text":"<p>To apply velocity to position, effectively moving entities within the game world.</p>"},{"location":"dev/ECS/Systems/#implementation","title":"Implementation","text":"<pre><code>void movement_system(Registry&amp; registry) {\n    auto&amp; positions = registry.get_components&lt;Position&gt;();\n    auto&amp; velocities = registry.get_components&lt;Velocity&gt;();\n\n    for (size_t i = 0; i &lt; positions.size() &amp;&amp; i &lt; velocities.size(); ++i) {\n        if (positions[i] &amp;&amp; velocities[i]) {\n            positions[i]-&gt;x += velocities[i]-&gt;vx;\n            positions[i]-&gt;y += velocities[i]-&gt;vy;\n        }\n    }\n}\n</code></pre>"},{"location":"dev/ECS/Systems/#explanation","title":"Explanation","text":"<ul> <li>Iterates through entities with <code>Position</code> and <code>Velocity</code> components.</li> <li>Updates the <code>x</code> and <code>y</code> attributes of the position using the velocity values.</li> </ul>"},{"location":"dev/ECS/Systems/#2-timer-system","title":"2. Timer System","text":"<p>The Timer System tracks durations and executes actions when timers expire.</p>"},{"location":"dev/ECS/Systems/#purpose_1","title":"Purpose","text":"<p>To manage timed events for entities, such as animations or cooldowns.</p>"},{"location":"dev/ECS/Systems/#implementation_1","title":"Implementation","text":"<pre><code>class TimerSystem {\npublic:\n    void update(ECS::Registry&amp; registry, float deltaTime) {\n        auto&amp; timers = registry.get_components&lt;Timer&gt;();\n\n        for (size_t i = 0; i &lt; timers.size(); ++i) {\n            if (!timers[i]) continue;\n\n            auto&amp; timer = *timers[i];\n            timer.elapsed += deltaTime;\n\n            if (timer.elapsed &gt;= timer.duration) {\n                timer.elapsed = 0.0f;\n                if (!timer.repeat) {\n                    registry.remove_component&lt;Timer&gt;(i);\n                }\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"dev/ECS/Systems/#explanation_1","title":"Explanation","text":"<ul> <li>Updates each timer\u2019s elapsed time.</li> <li>Resets or removes the timer when it expires, based on its <code>repeat</code> flag.</li> </ul>"},{"location":"dev/ECS/Systems/#3-physics-system","title":"3. Physics System","text":"<p>The Physics System handles interactions like collisions between entities.</p>"},{"location":"dev/ECS/Systems/#purpose_2","title":"Purpose","text":"<p>To process and resolve physical interactions.</p>"},{"location":"dev/ECS/Systems/#implementation-example-placeholder","title":"Implementation (Example Placeholder)","text":"<pre><code>void physics_system(Registry&amp; registry) {\n    // Example collision resolution logic here.\n}\n</code></pre>"},{"location":"dev/ECS/Systems/#explanation_2","title":"Explanation","text":"<ul> <li>Identifies entities with collidable components.</li> <li>Resolves overlaps, applying forces or constraints as needed.</li> </ul>"},{"location":"dev/ECS/Systems/#relationship-with-core-components","title":"Relationship with Core Components","text":"<p>Systems leverage the <code>Registry</code> to access components and iterate over entities. For example:</p> <ul> <li>The <code>Movement System</code> accesses <code>Position</code> and <code>Velocity</code> components.</li> <li>The <code>Timer System</code> interacts with <code>Timer</code> components.</li> <li>The <code>Physics System</code> may combine <code>Position</code>, <code>Velocity</code>, and <code>Collidable</code> components.</li> </ul>"},{"location":"dev/ECS/Systems/#diagram","title":"Diagram","text":"<pre><code>[System]\n    |\n    +---&gt; [Registry]\n    |          +---&gt; [SparseArray&lt;Component&gt;]\n    +---&gt; [Entities with Components]\n</code></pre>"},{"location":"dev/ECS/Systems/#file-references","title":"File References","text":"<ul> <li>Core Components: Details on <code>Registry</code> and <code>SparseArray</code>.</li> <li>System Manager: Managing and executing multiple systems.</li> <li>Schemas and Diagrams: Visual flow of how systems interact with components and entities.</li> </ul>"},{"location":"dev/ECS/Systems/#next-steps","title":"Next Steps","text":"<p>Proceed to Event Management to explore how events integrate with systems for decoupled logic and dynamic interactions.</p>"},{"location":"dev/Network/Client/","title":"Client","text":""},{"location":"dev/Network/Client/#clientmd","title":"Client.md","text":""},{"location":"dev/Network/Client/#purpose","title":"Purpose:","text":"<p>The <code>Client</code> class manages client-side interactions for the R-Type game. It handles the connection to the server, sending messages, and receiving responses. This class encapsulates network communication for the client.</p>"},{"location":"dev/Network/Client/#includes","title":"Includes:","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;memory&gt;\n#include &lt;json/json.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;unistd.h&gt;\n</code></pre>"},{"location":"dev/Network/Client/#file-description","title":"File Description:","text":"<p>The <code>Client</code> class facilitates communication with the game server over TCP. It provides methods to establish a connection, send a connection request with the player's username, and process server responses.</p>"},{"location":"dev/Network/Client/#key-functions","title":"Key Functions:","text":""},{"location":"dev/Network/Client/#constructor","title":"Constructor:","text":"<p><pre><code>Client(const std::string &amp;serverAddress, int serverPort);\n</code></pre> - Initializes the client with the server's IP address and port. - Sets up the TCP socket for communication.</p>"},{"location":"dev/Network/Client/#destructor","title":"Destructor:","text":"<p><pre><code>~Client();\n</code></pre> - Closes the TCP socket upon destruction if it is open.</p>"},{"location":"dev/Network/Client/#function-connecttoserver","title":"Function: connectToServer","text":"<p><pre><code>void connectToServer();\n</code></pre> - Establishes a TCP connection to the server. - Prints a success or failure message to the console.</p>"},{"location":"dev/Network/Client/#function-sendconnectrequest","title":"Function: sendConnectRequest","text":"<p><pre><code>void sendConnectRequest(const std::string &amp;username);\n</code></pre> - Sends a JSON-formatted connection request containing the player's username to the server. - Prints the sent username to the console.</p>"},{"location":"dev/Network/Client/#function-receiveresponse","title":"Function: receiveResponse","text":"<p><pre><code>void receiveResponse();\n</code></pre> - Listens for and processes responses from the server. - Prints the received response or an error message.</p>"},{"location":"dev/Network/Client/#example-usage","title":"Example Usage:","text":"<pre><code>int main() {\n    std::string serverAddress = \"127.0.0.1\";\n    int serverPort = 4242;\n\n    rtype::Client client(serverAddress, serverPort);\n    client.connectToServer();\n    client.sendConnectRequest(\"Player1\");\n    client.receiveResponse();\n\n    return 0;\n}\n</code></pre>"},{"location":"dev/Network/Client/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Modularity:</li> <li>Separate methods for connecting, sending requests, and receiving responses make the class easy to maintain and extend.</li> <li>Error Handling:</li> <li>Errors during socket creation, connection, or communication are logged to the console for debugging.</li> <li>Scalability:</li> <li>Additional methods can be added for other client-side functionalities like game events or chat messages.</li> </ul>"},{"location":"dev/Network/Client/#collaboration","title":"Collaboration:","text":"<ul> <li>Communicates with the server (<code>Server</code> class).</li> <li>Utilizes JSON for message formatting and parsing.</li> <li>Works alongside <code>Player</code> and <code>Entity</code> components for game-related data.</li> </ul>"},{"location":"dev/Network/Client/#summary","title":"Summary:","text":"<p>The <code>Client</code> class is a critical component of the R-Type game's network module. It handles the essential tasks of connecting to the server, sending player details, and processing server responses, ensuring seamless client-server communication.</p>"},{"location":"dev/Network/Enemy/","title":"Enemy","text":""},{"location":"dev/Network/Enemy/#enemymd","title":"Enemy.md","text":""},{"location":"dev/Network/Enemy/#purpose","title":"Purpose:","text":"<p>The <code>Enemy</code> structure and its related functionalities are essential for managing enemy entities in the R-Type game. This documentation provides details about its attributes and integration into the game's systems.</p>"},{"location":"dev/Network/Enemy/#implementation-location","title":"Implementation Location:","text":"<p><code>Server.hpp</code></p>"},{"location":"dev/Network/Enemy/#description","title":"Description:","text":"<p>The <code>Enemy</code> structure represents a single enemy entity within a game room. It encapsulates its attributes and behaviors.</p>"},{"location":"dev/Network/Enemy/#attributes","title":"Attributes:","text":""},{"location":"dev/Network/Enemy/#id","title":"<code>id</code>","text":"<ul> <li>Type: <code>uint32_t</code></li> <li>Description: Unique identifier for the enemy.</li> </ul>"},{"location":"dev/Network/Enemy/#x","title":"<code>x</code>","text":"<ul> <li>Type: <code>float</code></li> <li>Description: X-coordinate position of the enemy on the game map.</li> </ul>"},{"location":"dev/Network/Enemy/#y","title":"<code>y</code>","text":"<ul> <li>Type: <code>float</code></li> <li>Description: Y-coordinate position of the enemy on the game map.</li> </ul>"},{"location":"dev/Network/Enemy/#integration","title":"Integration:","text":"<ul> <li>Room Management:    Enemies are part of the <code>Room</code> structure and are managed within the <code>rooms</code> map in the <code>Server</code> class.</li> <li>Spawn Logic:    Enemies are spawned dynamically by calling the <code>spawnEnemy</code> function in the <code>Server</code> class.</li> </ul>"},{"location":"dev/Network/Enemy/#key-functions","title":"Key Functions:","text":""},{"location":"dev/Network/Enemy/#function-spawnenemy","title":"Function: <code>spawnEnemy</code>","text":"<p><pre><code>void spawnEnemy(uint32_t roomId);\n</code></pre> - Purpose:   Spawns an enemy at a random position in the specified room. - Logic:   - Generates a random X and Y position for the enemy.   - Assigns a unique ID to the enemy.   - Adds the enemy to the <code>enemies</code> map in the corresponding <code>Room</code>.   - Broadcasts the enemy spawn message to all players in the room.</p>"},{"location":"dev/Network/Enemy/#function-broadcastennemiemovement","title":"Function: <code>broadcastEnnemieMovement</code>","text":"<p><pre><code>void broadcastEnnemieMovement();\n</code></pre> - Purpose:   Broadcasts enemy movement updates to all players in the respective rooms. - Logic:   - Iterates over all active rooms and their enemies.   - Prepares and sends a movement update message for each enemy to the players.</p>"},{"location":"dev/Network/Enemy/#communication","title":"Communication:","text":"<ul> <li>UDP Messages:   Enemies' movements and spawns are communicated to players via UDP messages.</li> </ul>"},{"location":"dev/Network/Enemy/#example-spawn-broadcast","title":"Example Spawn Broadcast:","text":"<p>Message Type: <code>0x09</code> - Payload:   - <code>enemyId</code>: Identifier of the enemy.   - <code>x</code>: X-coordinate.   - <code>y</code>: Y-coordinate.</p>"},{"location":"dev/Network/Enemy/#example-integration","title":"Example Integration:","text":""},{"location":"dev/Network/Enemy/#spawning-an-enemy","title":"Spawning an Enemy","text":"<pre><code>server.spawnEnemy(roomId);\n</code></pre>"},{"location":"dev/Network/Enemy/#broadcasting-enemy-movement","title":"Broadcasting Enemy Movement","text":"<pre><code>server.broadcastEnnemieMovement();\n</code></pre>"},{"location":"dev/Network/Enemy/#summary","title":"Summary:","text":"<p>The <code>Enemy</code> structure and its associated logic provide a streamlined approach for managing enemies in the game. From spawning to broadcasting movements, the system ensures consistent and efficient gameplay mechanics.</p>"},{"location":"dev/Network/Entity/","title":"Entity","text":""},{"location":"dev/Network/Entity/#entitymd","title":"Entity.md","text":""},{"location":"dev/Network/Entity/#purpose","title":"Purpose:","text":"<p>The <code>Entity</code> class serves as the base class for game entities in the R-Type project. It defines the common interface and properties that all entities (such as players, enemies, or other in-game objects) must implement.</p>"},{"location":"dev/Network/Entity/#file-location","title":"File Location:","text":"<p><code>src/Network/Entity.hpp</code></p>"},{"location":"dev/Network/Entity/#key-responsibilities","title":"Key Responsibilities:","text":"<ul> <li>Provide a common interface for accessing and modifying entity positions.</li> <li>Serve as a parent class for specific entity implementations, such as <code>Player</code>.</li> </ul>"},{"location":"dev/Network/Entity/#class-definition","title":"Class Definition:","text":""},{"location":"dev/Network/Entity/#class-entity","title":"Class: <code>Entity</code>","text":"<pre><code>class Entity {\npublic:\n    virtual ~Entity() = 0;\n    virtual float getXposition() = 0;\n    virtual float getYposition() = 0;\n    virtual float setXposition(float x) = 0;\n    virtual float setYposition(float y) = 0;\n\nprotected:\n    float _x;\n    float _y;\n};\n</code></pre>"},{"location":"dev/Network/Entity/#key-methods","title":"Key Methods:","text":""},{"location":"dev/Network/Entity/#destructor","title":"Destructor:","text":"<p><pre><code>virtual ~Entity() = 0;\n</code></pre> - Defined as a pure virtual destructor to make <code>Entity</code> an abstract class. - Ensures that all derived classes provide their own implementation.</p>"},{"location":"dev/Network/Entity/#getters-and-setters","title":"Getters and Setters:","text":"<p><pre><code>virtual float getXposition() = 0;\nvirtual float getYposition() = 0;\nvirtual float setXposition(float x) = 0;\nvirtual float setYposition(float y) = 0;\n</code></pre> - Purpose:   - <code>getXposition</code> and <code>getYposition</code> retrieve the entity's position.   - <code>setXposition</code> and <code>setYposition</code> modify the entity's position. - Implementation: Must be defined in derived classes, such as <code>Player</code>.</p>"},{"location":"dev/Network/Entity/#usage","title":"Usage:","text":"<p>The <code>Entity</code> class is not directly instantiated but serves as a base class for entities that require position management.</p> <p>Example: <pre><code>class Player : public Entity {\npublic:\n    float getXposition() override {\n        return _x;\n    }\n\n    float getYposition() override {\n        return _y;\n    }\n\n    float setXposition(float x) override {\n        _x = x;\n        return _x;\n    }\n\n    float setYposition(float y) override {\n        _y = y;\n        return _y;\n    }\n};\n</code></pre></p>"},{"location":"dev/Network/Entity/#collaboration","title":"Collaboration:","text":"<ul> <li>Player: Inherits from <code>Entity</code> to define specific behaviors for player entities.</li> <li>Server: May use <code>Entity</code>-derived objects to manage positions of game elements.</li> </ul>"},{"location":"dev/Network/Entity/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Abstraction:</li> <li>The <code>Entity</code> class ensures that all derived entities share a consistent interface for position management.</li> <li>Flexibility:</li> <li>By making the class abstract, it allows other entities to implement their own logic while adhering to the interface.</li> </ul>"},{"location":"dev/Network/Entity/#summary","title":"Summary:","text":"<p><code>Entity</code> is a foundational class that provides a consistent interface for managing position-related data in the R-Type project. Its abstract design ensures flexibility and scalability for various entity types.</p>"},{"location":"dev/Network/Exception/","title":"Exception","text":""},{"location":"dev/Network/Exception/#exceptionmd","title":"Exception.md","text":""},{"location":"dev/Network/Exception/#purpose","title":"Purpose","text":"<p>The <code>Exception</code> class provides a mechanism for custom exception handling within the R-Type project. It is designed to simplify error reporting and debugging by allowing descriptive error messages to be propagated and displayed.</p>"},{"location":"dev/Network/Exception/#location","title":"Location","text":"<p>This file is part of the Network module in the R-Type project documentation.</p>"},{"location":"dev/Network/Exception/#file-content","title":"File Content","text":""},{"location":"dev/Network/Exception/#header-file-exceptionhpp","title":"Header File: Exception.hpp","text":"<pre><code>#ifndef EXCEPTION_HPP_\n#define EXCEPTION_HPP_\n\n#include &lt;iostream&gt;\n#include &lt;exception&gt;\n\nnamespace rtype {\n\n    class Exception : public std::exception {\n        public:\n            Exception(const std::string &amp;message) {\n                this-&gt;_message = message;\n            }\n            ~Exception() noexcept = default;\n            const char *what() const noexcept override { return _message.c_str(); }\n        protected:\n        private:\n            std::string _message;\n    };\n\n}\n\n#endif /* !EXCEPTION_HPP_ */\n</code></pre>"},{"location":"dev/Network/Exception/#key-components","title":"Key Components","text":""},{"location":"dev/Network/Exception/#class-exception","title":"Class: <code>Exception</code>","text":"<ul> <li> <p>Purpose:   The <code>Exception</code> class is a simple extension of the standard <code>std::exception</code> class, allowing for custom error messages.</p> </li> <li> <p>Public Methods:</p> </li> <li><code>Exception(const std::string &amp;message)</code><ul> <li>Constructor to initialize the exception with a custom message.</li> </ul> </li> <li><code>~Exception() noexcept</code><ul> <li>Default destructor ensuring no exceptions are thrown during destruction.</li> </ul> </li> <li><code>const char *what() const noexcept</code><ul> <li>Overridden method to return the custom error message.</li> </ul> </li> </ul>"},{"location":"dev/Network/Exception/#private-members","title":"Private Members:","text":"<ul> <li><code>_message</code></li> <li>Stores the custom error message provided during the exception's instantiation.</li> </ul>"},{"location":"dev/Network/Exception/#example-usage","title":"Example Usage","text":"<p><pre><code>#include \"Exception.hpp\"\n#include &lt;iostream&gt;\n\nint main() {\n    try {\n        throw rtype::Exception(\"A custom error occurred.\");\n    } catch (const rtype::Exception &amp;e) {\n        std::cerr &lt;&lt; \"Error: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre> Output: <pre><code>Error: A custom error occurred.\n</code></pre></p>"},{"location":"dev/Network/Exception/#integration","title":"Integration","text":"<p>The <code>Exception</code> class is used throughout the Network module to handle errors such as connection failures, invalid data, or server-related issues. By using this class, developers can provide detailed and consistent error reporting.</p>"},{"location":"dev/Network/Exception/#summary","title":"Summary","text":"<ul> <li>Modularity:</li> <li>The <code>Exception</code> class encapsulates error handling, ensuring clean and maintainable code.</li> <li>Extensibility:</li> <li>The class can be extended or modified to include additional features, such as error codes or logging.</li> <li>Ease of Use:</li> <li>The API is straightforward, leveraging the familiar <code>std::exception</code> interface.</li> </ul>"},{"location":"dev/Network/IServer/","title":"IServer","text":""},{"location":"dev/Network/IServer/#iservermd","title":"IServer.md","text":""},{"location":"dev/Network/IServer/#purpose","title":"Purpose:","text":"<p><code>IServer</code> defines the interface for the server implementation in the Network module of the R-Type project. It provides an abstraction layer for the server's functionality and serves as a blueprint for concrete server implementations.</p>"},{"location":"dev/Network/IServer/#location","title":"Location:","text":"<p>Path: <code>Network/IServer.hpp</code></p>"},{"location":"dev/Network/IServer/#key-features","title":"Key Features:","text":"<ul> <li>Interface Design: Provides a uniform structure for the server to implement essential functionalities.</li> <li>Integration: Ensures compatibility and modularity within the Network module.</li> </ul>"},{"location":"dev/Network/IServer/#includes","title":"Includes:","text":"<pre><code>#include &lt;asio.hpp&gt;\n</code></pre>"},{"location":"dev/Network/IServer/#file-description","title":"File Description:","text":"<p>The <code>IServer</code> file defines the <code>IServer</code> class, which outlines a single core function: - <code>run</code>: Executes the server logic using an <code>asio::io_context</code> object.</p>"},{"location":"dev/Network/IServer/#class-details","title":"Class Details:","text":""},{"location":"dev/Network/IServer/#class-iserver","title":"Class: IServer","text":"<pre><code>class IServer {\npublic:\n    virtual void run(asio::io_context&amp; io_context);\n};\n</code></pre>"},{"location":"dev/Network/IServer/#functionality","title":"Functionality:","text":"<ul> <li><code>run(asio::io_context &amp;io_context)</code></li> <li>Purpose: Starts the server loop and manages its operations.</li> <li>Input:<ul> <li><code>asio::io_context &amp;io_context</code>: Context object for managing asynchronous I/O.</li> </ul> </li> <li>Behavior: Abstract function to be overridden by the implementing server class. It is responsible for the main operational logic of the server.</li> </ul>"},{"location":"dev/Network/IServer/#example-usage","title":"Example Usage:","text":"<p>This file only defines an interface and cannot be used directly. Below is a potential implementation in a derived class: <pre><code>class ConcreteServer : public IServer {\npublic:\n    void run(asio::io_context &amp;io_context) override {\n        // Server logic here\n        io_context.run();\n    }\n};\n</code></pre></p>"},{"location":"dev/Network/IServer/#summary","title":"Summary:","text":"<p><code>IServer</code> establishes a standard for server implementation in the Network module. By defining the core <code>run</code> method, it ensures that any server implementation adheres to a consistent structure, fostering modularity and ease of integration.</p>"},{"location":"dev/Network/Network/","title":"Network Overview","text":""},{"location":"dev/Network/Network/#purpose","title":"Purpose","text":"<p>The network component of the R-Type project is designed to enable multiplayer functionality through a combination of TCP and UDP protocols. It facilitates communication between the client and the server, allowing for real-time interactions such as player movements, shooting, and game state synchronization.</p>"},{"location":"dev/Network/Network/#components","title":"Components","text":""},{"location":"dev/Network/Network/#1-server","title":"1. Server","text":"<p>The server manages all game rooms, players, and network messages. It ensures that game states are synchronized across all connected clients.</p>"},{"location":"dev/Network/Network/#key-features","title":"Key Features:","text":"<ul> <li>Room management (creation, deletion, and joining).</li> <li>Broadcasting player movements and actions.</li> <li>Handling enemy spawning and shield pickups.</li> <li>Communicating with clients via UDP for real-time updates.</li> <li>Handling player disconnections.</li> </ul>"},{"location":"dev/Network/Network/#main-functions","title":"Main Functions:","text":"<ul> <li><code>run(asio::io_context &amp;io_context)</code>: Starts the server and processes asynchronous operations.</li> <li><code>start_receive()</code>: Listens for incoming UDP messages from clients.</li> <li><code>createRoom(uint32_t numberMaxPlayer, std::string name)</code>: Creates a new game room.</li> <li><code>deleteRoom(uint32_t roomId)</code>: Deletes an existing room.</li> <li><code>joinRoom(uint32_t roomId, std::shared_ptr&lt;Client&gt; newClient)</code>: Adds a player to a specified room.</li> <li><code>broadcastPlayerMovement(uint32_t playerId, float posX, float posY, uint32_t roomId)</code>: Broadcasts player position updates.</li> <li><code>spawnEnemy(uint32_t roomId)</code>: Spawns enemies in a specific room.</li> <li><code>broadcastEnnemieMovement()</code>: Broadcasts enemy positions to all players.</li> <li><code>spawnShield(uint32_t roomId)</code>: Spawns shields in the game room.</li> <li><code>broadcastShieldPickup(uint32_t shieldId, uint32_t roomId)</code>: Notifies all players when a shield is picked up.</li> </ul>"},{"location":"dev/Network/Network/#data-structures","title":"Data Structures:","text":"<ul> <li><code>Room</code>: Represents a game room, containing players, enemies, shields, and room settings.</li> <li><code>Client</code>: Represents a player, including ID, username, and network endpoint.</li> <li><code>Enemy</code> &amp; <code>Shield</code>: Represent game objects with position and ID.</li> </ul>"},{"location":"dev/Network/Network/#2-client","title":"2. Client","text":"<p>The client communicates with the server to send actions (e.g., movement, shooting) and receive updates.</p>"},{"location":"dev/Network/Network/#key-features_1","title":"Key Features:","text":"<ul> <li>TCP-based connection setup.</li> <li>UDP-based real-time data exchange.</li> <li>Sending connection requests with a username.</li> <li>Receiving game state updates (e.g., enemy movements, player actions).</li> </ul>"},{"location":"dev/Network/Network/#main-functions_1","title":"Main Functions:","text":"<ul> <li><code>connectToServer()</code>: Establishes a TCP connection with the server.</li> <li><code>sendConnectRequest(const std::string &amp;username)</code>: Sends a connection request containing the player's username.</li> <li><code>receiveResponse()</code>: Processes responses from the server.</li> </ul>"},{"location":"dev/Network/Network/#3-protocols","title":"3. Protocols","text":""},{"location":"dev/Network/Network/#tcp","title":"TCP:","text":"<ul> <li>Used for reliable, ordered communication.</li> <li>Handles connection setup and teardown.</li> <li>Transfers large messages, such as connection requests and game initialization.</li> </ul>"},{"location":"dev/Network/Network/#udp","title":"UDP:","text":"<ul> <li>Used for real-time communication (e.g., player movements, shooting).</li> <li>Offers low latency at the cost of reliability.</li> </ul>"},{"location":"dev/Network/Network/#communication-flow","title":"Communication Flow","text":""},{"location":"dev/Network/Network/#1-connection-initialization","title":"1. Connection Initialization:","text":"<ol> <li>The client establishes a TCP connection to the server.</li> <li>The client sends a connection request with its username.</li> <li>The server responds with confirmation and game state initialization data.</li> </ol>"},{"location":"dev/Network/Network/#2-gameplay-communication","title":"2. Gameplay Communication:","text":"<ul> <li>Player Actions:</li> <li>Players send movement and shooting messages via UDP.</li> <li> <p>The server processes and broadcasts these actions to other players in the same room.</p> </li> <li> <p>Enemy and Shield Updates:</p> </li> <li>The server spawns enemies and shields periodically.</li> <li>Updates are broadcasted to all players in the room.</li> </ul>"},{"location":"dev/Network/Network/#3-disconnection","title":"3. Disconnection:","text":"<ul> <li>The server detects disconnection events and removes the player from the corresponding room.</li> </ul>"},{"location":"dev/Network/Network/#design-considerations","title":"Design Considerations","text":"<ol> <li>Real-Time Responsiveness:</li> <li> <p>UDP is used for time-sensitive updates to minimize latency.</p> </li> <li> <p>Reliability:</p> </li> <li> <p>TCP ensures reliable delivery of critical messages (e.g., connection setup).</p> </li> <li> <p>Scalability:</p> </li> <li>Rooms allow multiple games to run independently.</li> <li> <p>Each room handles its own set of players and game objects.</p> </li> <li> <p>Error Handling:</p> </li> <li>Robust error handling ensures the server continues running despite individual failures (e.g., player disconnections).</li> </ol>"},{"location":"dev/Network/Network/#example-usage","title":"Example Usage","text":""},{"location":"dev/Network/Network/#client-code","title":"Client Code:","text":"<pre><code>#include \"Client.hpp\"\n\nint main() {\n    std::string serverAddress = \"127.0.0.1\";\n    int serverPort = 4242;\n    rtype::Client client(serverAddress, serverPort);\n\n    client.connectToServer();\n    client.sendConnectRequest(\"Player1\");\n    client.receiveResponse();\n\n    return 0;\n}\n</code></pre>"},{"location":"dev/Network/Network/#server-initialization","title":"Server Initialization:","text":"<p>```cpp asio::io_context io_context; rtype::Server server(io_context, \"127.0.0.1\", 4343, \"My R-Type Server\"); server.run(io_context);</p>"},{"location":"dev/Network/Player/","title":"Player.md","text":""},{"location":"dev/Network/Player/#purpose","title":"Purpose:","text":"<p>The <code>Player</code> class represents individual players in the R-Type game. Each player has unique attributes like ID, username, position, and an associated UDP endpoint for network communication.</p>"},{"location":"dev/Network/Player/#key-features","title":"Key Features:","text":"<ul> <li>Tracks player-specific information, such as their position and username.</li> <li>Provides an interface to modify and access player attributes.</li> <li>Encapsulates networking-related details like the UDP endpoint.</li> </ul>"},{"location":"dev/Network/Player/#header-file-playerhpp","title":"Header File: <code>Player.hpp</code>","text":""},{"location":"dev/Network/Player/#key-attributes","title":"Key Attributes:","text":"<pre><code>private:\n    uint32_t _id;                // Unique player ID\n    std::string _username;       // Player's username\n    struct sockaddr_in _udpEndpoint; // Player's network endpoint\n    float _x;                    // X-coordinate position\n    float _y;                    // Y-coordinate position\n</code></pre>"},{"location":"dev/Network/Player/#key-methods","title":"Key Methods:","text":"<pre><code>public:\n    Player(uint32_t playerId);   // Constructor initializes player ID\n    ~Player();                   // Destructor\n\n    uint32_t getID() const;      // Retrieves player ID\n    void setID(uint32_t id);     // Sets player ID\n\n    std::string getUsername() const;  // Retrieves player's username\n    void setUsername(const std::string &amp;username); // Sets player's username\n\n    struct sockaddr_in&amp; getUDPEndpoint(); // Accesses player's UDP endpoint\n    void setUDPEndpoint(const struct sockaddr_in &amp;endpoint); // Sets UDP endpoint\n\n    float getXposition() override; // Retrieves X-coordinate\n    float getYposition() override; // Retrieves Y-coordinate\n    float setXposition(float x) override; // Updates X-coordinate\n    float setYposition(float y) override; // Updates Y-coordinate\n</code></pre>"},{"location":"dev/Network/Player/#implementation-file-playercpp","title":"Implementation File: <code>Player.cpp</code>","text":""},{"location":"dev/Network/Player/#constructor-and-destructor","title":"Constructor and Destructor:","text":"<ul> <li><code>Player::Player(uint32_t playerId)</code>: Initializes a player with the specified ID and default position <code>(0.0f, 0.0f)</code>.</li> <li><code>Player::~Player()</code>: Handles cleanup when a player object is destroyed.</li> </ul>"},{"location":"dev/Network/Player/#attribute-management","title":"Attribute Management:","text":"<ul> <li> <p>ID Management: <pre><code>uint32_t Player::getID() const {\n    return this-&gt;_id;\n}\n\nvoid Player::setID(uint32_t id) {\n    this-&gt;_id = id;\n}\n</code></pre></p> </li> <li> <p>Username Management: <pre><code>std::string Player::getUsername() const {\n    return this-&gt;_username;\n}\n\nvoid Player::setUsername(const std::string &amp;username) {\n    this-&gt;_username = username;\n}\n</code></pre></p> </li> <li> <p>Position Management: <pre><code>float Player::getXposition() {\n    return this-&gt;_x;\n}\n\nfloat Player::getYposition() {\n    return this-&gt;_y;\n}\n\nfloat Player::setXposition(float x) {\n    this-&gt;_x = x;\n    return this-&gt;_x;\n}\n\nfloat Player::setYposition(float y) {\n    this-&gt;_y = y;\n    return this-&gt;_y;\n}\n</code></pre></p> </li> <li> <p>UDP Endpoint Management: <pre><code>struct sockaddr_in&amp; Player::getUDPEndpoint() {\n    return this-&gt;_udpEndpoint;\n}\n\nvoid Player::setUDPEndpoint(const struct sockaddr_in &amp;endpoint) {\n    this-&gt;_udpEndpoint = endpoint;\n}\n</code></pre></p> </li> </ul>"},{"location":"dev/Network/Player/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Encapsulation:</li> <li> <p>The class provides a clean interface to manage player-specific data while encapsulating implementation details.</p> </li> <li> <p>Integration with Network Module:</p> </li> <li> <p>The <code>Player</code> class works closely with the <code>Server</code> class for managing player communication over UDP.</p> </li> <li> <p>Scalability:</p> </li> <li>Supports expansion to include more player-related features such as inventory, health, or score tracking.</li> </ul>"},{"location":"dev/Network/Player/#collaboration","title":"Collaboration:","text":"<ul> <li>Server Class:</li> <li>The <code>Player</code> objects are managed by the <code>Server</code> class, which uses their attributes for communication and game state updates.</li> </ul>"},{"location":"dev/Network/Player/#example-usage","title":"Example Usage:","text":"<pre><code>#include \"Player.hpp\"\n\nrtype::Player player(1); // Create a player with ID 1\nplayer.setUsername(\"PlayerOne\");\nplayer.setXposition(100.0f);\nplayer.setYposition(200.0f);\n\nstd::cout &lt;&lt; \"Player \" &lt;&lt; player.getUsername() &lt;&lt; \" is at (\"\n          &lt;&lt; player.getXposition() &lt;&lt; \", \" &lt;&lt; player.getYposition() &lt;&lt; \")\\n\";\n</code></pre>"},{"location":"dev/Network/Player/#summary","title":"Summary:","text":"<p>The <code>Player</code> class is a fundamental component of the R-Type game's network and gameplay systems. It ensures efficient and organized management of player-specific data and integrates seamlessly with other modules.</p>"},{"location":"dev/Network/Projectile/","title":"Projectile","text":""},{"location":"dev/Network/Projectile/#projectilemd","title":"Projectile.md","text":""},{"location":"dev/Network/Projectile/#purpose","title":"Purpose","text":"<p>The <code>Projectile</code> system is responsible for defining the behavior, types, and attributes of projectiles in the game. Projectiles are used for various in-game mechanics, such as player and enemy attacks.</p>"},{"location":"dev/Network/Projectile/#includes","title":"Includes","text":"<pre><code>#include \"ProjectileType.hpp\"\n#include \"Position.hpp\"\n#include \"Velocity.hpp\"\n#include \"Collision.hpp\"\n#include \"GameCommon.hpp\"\n</code></pre>"},{"location":"dev/Network/Projectile/#file-description","title":"File Description","text":"<p>This file contains the <code>Projectile</code> system, which defines the core properties and behaviors of projectiles within the game. It handles initialization, updates, and interactions of projectile entities in the ECS framework.</p>"},{"location":"dev/Network/Projectile/#key-components-and-systems","title":"Key Components and Systems","text":""},{"location":"dev/Network/Projectile/#projectiletype","title":"ProjectileType","text":"<p>Defines the type of the projectile, including: - Damage value. - Speed. - Direction. - Special properties (e.g., explosive, piercing).</p>"},{"location":"dev/Network/Projectile/#position","title":"Position","text":"<p>Tracks the projectile's position in the game world.</p>"},{"location":"dev/Network/Projectile/#velocity","title":"Velocity","text":"<p>Determines the projectile's movement by applying velocity vectors to its position.</p>"},{"location":"dev/Network/Projectile/#collision","title":"Collision","text":"<p>Detects interactions between the projectile and other entities (e.g., players, enemies, walls).</p>"},{"location":"dev/Network/Projectile/#functions-and-behavior","title":"Functions and Behavior","text":""},{"location":"dev/Network/Projectile/#function-createprojectile","title":"Function: createProjectile","text":"<p><pre><code>void createProjectile(ECS::Registry &amp;registry, float x, float y, float speed, Direction direction, ProjectileType type);\n</code></pre> - Spawns a new projectile entity. - Assigns necessary components, such as <code>Position</code>, <code>Velocity</code>, <code>ProjectileType</code>, and <code>Collision</code>. - Configures the projectile's speed and direction based on input parameters.</p>"},{"location":"dev/Network/Projectile/#function-updateprojectiles","title":"Function: updateProjectiles","text":"<p><pre><code>void updateProjectiles(ECS::Registry &amp;registry, float deltaTime);\n</code></pre> - Updates projectile positions based on their velocity and direction. - Handles interactions, such as collision detection and damage application. - Removes projectiles that leave the game bounds or collide with targets.</p>"},{"location":"dev/Network/Projectile/#collaboration","title":"Collaboration","text":"<p>The <code>Projectile</code> system interacts with the following: - MovementSystem: To update projectile positions over time. - CollisionSystem: To manage interactions with other entities. - HealthSystem: To apply damage to entities hit by projectiles.</p>"},{"location":"dev/Network/Projectile/#design-considerations","title":"Design Considerations","text":"<ul> <li>Efficiency: Optimized for handling a large number of projectiles simultaneously without impacting performance.</li> <li>Modularity: Supports easy addition of new projectile types and behaviors.</li> <li>Scalability: Designed to handle varying speeds, trajectories, and effects for different projectile types.</li> </ul>"},{"location":"dev/Network/Projectile/#example-usage","title":"Example Usage","text":"<pre><code>createProjectile(registry, playerX, playerY, 300.0f, Direction::UP, ProjectileType::PLAYER_BULLET);\nupdateProjectiles(registry, deltaTime);\n</code></pre>"},{"location":"dev/Network/Projectile/#summary","title":"Summary","text":"<p>The <code>Projectile</code> system is essential for implementing dynamic and interactive gameplay. By managing projectile entities and their interactions, it enables mechanics such as player attacks, enemy projectiles, and environmental effects.</p>"},{"location":"dev/Network/Server/","title":"Server","text":""},{"location":"dev/Network/Server/#servermd","title":"Server.md","text":""},{"location":"dev/Network/Server/#purpose","title":"Purpose:","text":"<p>The <code>Server</code> class orchestrates the server-side logic for the R-Type game. It manages player connections, rooms, and in-game events, ensuring a smooth multiplayer experience. The server is responsible for: - Handling UDP/TCP communication with clients. - Managing rooms, players, enemies, and shields. - Broadcasting events such as player movements, enemy spawns, and shield pickups.</p>"},{"location":"dev/Network/Server/#includes","title":"Includes:","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;mutex&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;asio.hpp&gt;\n#include \"raylib.h\"\n\n#include \"Player.hpp\"\n#include \"IServer.hpp\"\n</code></pre>"},{"location":"dev/Network/Server/#key-structures","title":"Key Structures:","text":""},{"location":"dev/Network/Server/#room","title":"Room","text":"<p>Represents a game room where players can interact with each other. <pre><code>struct Room {\n    std::unordered_map&lt;uint32_t, std::shared_ptr&lt;Client&gt;&gt; players;\n    std::unordered_map&lt;uint32_t, Enemy&gt; enemies;\n    std::unordered_map&lt;uint32_t, Shield&gt; shields;\n    uint32_t shieldCounter = 0;\n    uint32_t roomId;\n    bool isGameStarted;\n    uint32_t numberMaxPlayer;\n    uint32_t playerCounter;\n    uint32_t enemyCounter;\n    std::string roomName;\n};\n</code></pre></p>"},{"location":"dev/Network/Server/#server","title":"Server","text":"<p>Handles all server-side logic, including room management and message handling. <pre><code>class Server {\nprivate:\n    uint32_t id;\n    std::string servName;\n    asio::ip::udp::socket udpSocket;\n    asio::ip::udp::endpoint serverEndpoint;\n    std::mutex playersMutex;\n    std::mutex enemiesMutex;\n    std::mutex roomsMutex;\n\n    bool stopServer;\n    enum { max_length = 1024 };\n    char data_[max_length];\n\n    std::unordered_map&lt;uint32_t, std::shared_ptr&lt;Room&gt;&gt; rooms;\n\npublic:\n    int udpServPort;\n    Server(asio::io_context &amp;io_context, const std::string &amp;serverIP, int udpPort, std::string name);\n    ~Server();\n\n    void run(asio::io_context &amp;io_context);\n    void start_receive();\n    void createRoom(uint32_t numberMaxPlayer, std::string name);\n    bool deleteRoom(uint32_t roomId);\n    void joinRoom(uint32_t roomId, std::shared_ptr&lt;Client&gt; newClient);\n    void leaveRoom(uint32_t roomId, uint32_t playerId);\n    std::shared_ptr&lt;Room&gt; getRoom(uint32_t roomId);\n    void kickPlayer(uint32_t playerId, uint32_t roomId);\n\nprivate:\n    void handleMessage(uint8_t messageType, const char *buffer, size_t bytesRead, asio::ip::udp::endpoint serverEndpoint);\n    void handleDisconnect(uint32_t playerId);\n    void handleMoveMessage(const char *buffer);\n    void handleShootMessage(const char *buffer);\n    void broadcastPlayerMovement(uint32_t playerId, float posX, float posY, uint32_t roomId);\n    void broadcastEnnemieMovement();\n    void spawnEnemy(uint32_t roomId);\n    void enemySpawnLoop();\n    void spawnShield(uint32_t roomId);\n    void broadcastShieldPickup(uint32_t shieldId, uint32_t roomId);\n};\n</code></pre></p>"},{"location":"dev/Network/Server/#key-methods","title":"Key Methods:","text":""},{"location":"dev/Network/Server/#room-management","title":"Room Management","text":"<ul> <li>createRoom: Initializes a new room with a unique ID and specified parameters.</li> <li>deleteRoom: Removes a room from the server.</li> <li>joinRoom: Adds a player to a room, creating one if necessary.</li> <li>kickPlayer: Removes a player from a room.</li> </ul>"},{"location":"dev/Network/Server/#message-handling","title":"Message Handling","text":"<ul> <li>handleMessage: Processes incoming messages from clients.</li> <li>handleMoveMessage: Updates player movement and broadcasts the position.</li> <li>handleShootMessage: Handles shooting events and notifies other players in the room.</li> </ul>"},{"location":"dev/Network/Server/#gameplay-events","title":"Gameplay Events","text":"<ul> <li>spawnEnemy: Spawns an enemy in a room and notifies players.</li> <li>enemySpawnLoop: Periodically spawns enemies in active rooms.</li> <li>spawnShield: Generates a shield power-up and broadcasts it.</li> <li>broadcastShieldPickup: Notifies players of a shield pickup.</li> </ul>"},{"location":"dev/Network/Server/#collaboration","title":"Collaboration:","text":"<ul> <li>Client: Receives updates about gameplay, movement, and events from the server.</li> <li>Room: Holds the state of players, enemies, and game objects.</li> <li>ASIO: Manages asynchronous network operations for UDP communication.</li> </ul>"},{"location":"dev/Network/Server/#example-usage","title":"Example Usage:","text":"<pre><code>asio::io_context io_context;\nServer server(io_context, \"127.0.0.1\", 4343, \"R-Type Server\");\nserver.run(io_context);\n</code></pre>"},{"location":"dev/Network/Server/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Concurrency: Uses mutexes to ensure thread-safe access to shared resources.</li> <li>Error Handling: Catches exceptions during network operations to maintain stability.</li> <li>Scalability: Supports multiple rooms with dynamic player and object management.</li> </ul>"},{"location":"dev/Network/Server/#summary","title":"Summary:","text":"<p>The <code>Server</code> class is a central component of the R-Type game's multiplayer functionality. It provides robust room management, player coordination, and in-game event handling, ensuring a seamless and engaging experience for all participants.</p>"},{"location":"dev/RType/Introduction/","title":"Introduction","text":""},{"location":"dev/RType/Introduction/#introduction-to-the-r-type-game-project","title":"Introduction to the R-Type Game Project","text":""},{"location":"dev/RType/Introduction/#overview","title":"Overview:","text":"<p>R-Type is a side-scrolling shoot-em-up game where players control a spaceship to defeat waves of enemies, avoid obstacles, and collect power-ups. This project utilizes an Entity Component System (ECS) architecture for efficient game logic management.</p>"},{"location":"dev/RType/Introduction/#key-features","title":"Key Features:","text":"<ul> <li>Entity Component System (ECS):</li> <li>Decouples data (components) from logic (systems).</li> <li>Provides flexibility for adding new features and optimizing performance.</li> <li>Multiplayer Support:</li> <li>Includes a network module (<code>GameNetwork</code>) for player communication and entity synchronization.</li> <li>Interactive Power-Ups:</li> <li>Players can collect power-ups to enhance abilities.</li> <li>Dynamic Rendering:</li> <li>Uses the Raylib library for rendering sprites and animations.</li> <li>Modular Systems:</li> <li>Collision detection, enemy AI, input handling, and more are implemented as separate systems.</li> </ul>"},{"location":"dev/RType/Introduction/#project-structure","title":"Project Structure:","text":"<ol> <li>Core Systems:</li> <li><code>CollisionSystem</code>: Handles collision detection and resolution.</li> <li><code>EnemyShootingSystem</code>: Manages enemy projectile generation.</li> <li><code>InputSystem</code>: Processes player input for movement and shooting.</li> <li>Utilities:</li> <li><code>GameCommon</code>: Utility functions for shared gameplay elements (e.g., health bars).</li> <li><code>GameSetup</code>: Initializes ECS components and game systems.</li> <li><code>GameNetwork</code>: Manages networking for multiplayer support.</li> <li>Components:</li> <li>Defines data structures like <code>Position</code>, <code>Health</code>, <code>Velocity</code>, and <code>EntityType</code>.</li> <li>Assets:</li> <li>Textures, sounds, and animations used in the game.</li> </ol>"},{"location":"dev/RType/Introduction/#dependencies","title":"Dependencies:","text":"<ul> <li>Raylib: For graphics rendering.</li> <li>ASIO: For networking and asynchronous communication.</li> <li>C++ STL: Core language features and containers.</li> </ul>"},{"location":"dev/RType/Introduction/#development-goals","title":"Development Goals:","text":"<ul> <li>Create a scalable and maintainable codebase for extending gameplay features.</li> <li>Ensure smooth multiplayer experience with synchronized game states.</li> <li>Provide modular and reusable systems for efficient development.</li> </ul>"},{"location":"dev/RType/Introduction/#how-to-use-this-documentation","title":"How to Use This Documentation:","text":"<ul> <li>Start with <code>GameSetup</code> to understand initialization.</li> <li>Refer to individual system documentation for implementation details.</li> <li>Use <code>GameCommon</code> and <code>GameNetwork</code> for utilities and multiplayer functions.</li> </ul> <p>This document serves as the entry point for understanding the R-Type game project. For detailed system-level documentation, refer to the respective markdown files.</p>"},{"location":"dev/RType/collision_system/","title":"Collision System","text":""},{"location":"dev/RType/collision_system/#collisionsystemhpp","title":"CollisionSystem.hpp","text":""},{"location":"dev/RType/collision_system/#purpose","title":"Purpose:","text":"<p>Defines the system responsible for detecting and handling collisions between entities in the game world.</p>"},{"location":"dev/RType/collision_system/#includes","title":"Includes:","text":"<pre><code>#include &lt;iostream&gt;\n#include \"CollisionSystem.hpp\"\n#include \"Registry.hpp\"\n#include \"AudioManager.hpp\"\n#include \"Component.hpp\"\n#include \"GameCommon.hpp\"\n</code></pre>"},{"location":"dev/RType/collision_system/#file-description","title":"File Description:","text":"<p>This file defines the <code>CollisionSystem</code> class, which is part of the ECS architecture. The system is responsible for detecting and managing collisions between game entities such as players, enemies, projectiles, and power-ups.</p>"},{"location":"dev/RType/collision_system/#key-classes-and-functions","title":"Key Classes and Functions:","text":""},{"location":"dev/RType/collision_system/#class-collisionsystem","title":"Class: CollisionSystem","text":"<p>Constructor: <pre><code>CollisionSystem(Registry &amp;registry, AudioManager &amp;audioManager, float &amp;powerUpProgress, bool &amp;powerUpActive, float &amp;powerUpTimer);\n</code></pre> - Initializes the collision system with references to the ECS registry, audio manager, and power-up parameters.</p> <p>Functions:</p> <ol> <li>update(float delta_time):</li> <li> <p>Iterates through game entities to check for collisions and handle them accordingly.</p> </li> <li> <p>check_collision(const Position &amp;posA, const Hitbox &amp;boxA, const Position &amp;posB, const Hitbox &amp;boxB):</p> </li> <li> <p>Determines if two entities' hitboxes overlap.</p> </li> <li> <p>handle_collision(size_t entityA, size_t entityB):</p> </li> <li> <p>Resolves specific collision events based on entity types.</p> </li> <li> <p>remove_entity_components(size_t entity_index):</p> </li> <li> <p>Removes all components associated with an entity.</p> </li> <li> <p>handle_shield_pickup(size_t player_index, size_t shield_index):</p> </li> <li> <p>Handles the event when a player picks up a shield.</p> </li> <li> <p>handle_projectile_enemy_collision(size_t projectile_index, size_t enemy_index):</p> </li> <li> <p>Manages collisions between projectiles and enemies, updating health and score as necessary.</p> </li> <li> <p>handle_player_hit(size_t player_index):</p> </li> <li>Handles when the player is hit, applying shield or health deductions as required.</li> </ol>"},{"location":"dev/RType/collision_system/#collaboration","title":"Collaboration:","text":"<p>This file interacts with the following components and files: - Registry: For managing entities and components. - AudioManager: For playing sound effects during collisions. - Components: Utilizes <code>Position</code>, <code>Hitbox</code>, <code>EntityTypeComponent</code>, <code>Health</code>, and <code>ShieldComponent</code>. - GameCommon: Shared utility functions such as drawing health bars and power-up progress bars.</p>"},{"location":"dev/RType/collision_system/#example-usage","title":"Example Usage:","text":"<p>```cpp CollisionSystem collisionSystem(registry, audioManager, powerUpProgress, powerUpActive, powerUpTimer); collisionSystem.update(deltaTime);</p>"},{"location":"dev/RType/enemy_shooting_system/","title":"Enemy Shooting System","text":""},{"location":"dev/RType/enemy_shooting_system/#enemyshootingsystemhpp","title":"EnemyShootingSystem.hpp","text":""},{"location":"dev/RType/enemy_shooting_system/#purpose","title":"Purpose:","text":"<p>The <code>EnemyShootingSystem</code> class is responsible for managing enemy projectiles, including firing behavior, timing, and integration with the ECS architecture.</p>"},{"location":"dev/RType/enemy_shooting_system/#includes","title":"Includes:","text":"<pre><code>#include \"EnemyShootingSystem.hpp\"\n#include \"Registry.hpp\"\n#include \"Component.hpp\"\n#include &lt;iostream&gt;\n</code></pre>"},{"location":"dev/RType/enemy_shooting_system/#file-description","title":"File Description:","text":"<p>This file defines the <code>EnemyShootingSystem</code>, which handles periodic shooting actions for enemies in the game. The system ensures that enemies spawn projectiles at regular intervals, enhancing gameplay challenge.</p>"},{"location":"dev/RType/enemy_shooting_system/#key-classes-and-functions","title":"Key Classes and Functions:","text":""},{"location":"dev/RType/enemy_shooting_system/#class-enemyshootingsystem","title":"Class: EnemyShootingSystem","text":"<p>Constructor: <pre><code>EnemyShootingSystem(Registry &amp;registry);\n</code></pre> - Initializes the system with a reference to the ECS registry, which manages game entities and their components.</p> <p>Functions:</p> <ol> <li>update(float delta_time):</li> <li>Updates the state of the system every frame.</li> <li> <p>Tracks shooting intervals and triggers projectile creation when the timer elapses.</p> </li> <li> <p>shoot_projectiles():</p> </li> <li>Iterates over enemy entities and spawns projectiles at their positions.</li> <li>Assigns appropriate components (e.g., <code>Position</code>, <code>Velocity</code>, <code>EntityTypeComponent</code>, and <code>ProjectileTypeComponent</code>) to the new projectiles.</li> </ol>"},{"location":"dev/RType/enemy_shooting_system/#collaboration","title":"Collaboration:","text":"<p>This file interacts with: - Registry: To spawn new projectiles and manage components. - Components: Uses <code>Position</code>, <code>Velocity</code>, <code>EntityTypeComponent</code>, and <code>ProjectileTypeComponent</code> to define projectile behavior.</p>"},{"location":"dev/RType/enemy_shooting_system/#key-variables","title":"Key Variables:","text":"<ul> <li><code>shoot_timer</code>: Tracks time elapsed since the last projectile spawn.</li> <li><code>shoot_interval</code>: Determines how frequently enemies fire projectiles.</li> </ul>"},{"location":"dev/RType/enemy_shooting_system/#example-usage","title":"Example Usage:","text":"<pre><code>EnemyShootingSystem enemyShootingSystem(registry);\nwhile (gameRunning) {\n    float deltaTime = GetFrameTime();\n    enemyShootingSystem.update(deltaTime);\n}\n</code></pre>"},{"location":"dev/RType/enemy_shooting_system/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Scalability:</li> <li>The system supports multiple enemies firing independently.</li> <li>Can be extended to include different projectile types or firing patterns.</li> <li>Performance:</li> <li>Efficiently updates all enemies using ECS, minimizing redundant calculations.</li> </ul>"},{"location":"dev/RType/enemy_shooting_system/#summary","title":"Summary:","text":"<p>The <code>EnemyShootingSystem</code> is a critical gameplay system, ensuring dynamic enemy interactions through projectile attacks. It maintains a balance between challenge and performance, integrating seamlessly with other game systems.</p>"},{"location":"dev/RType/enemy_spawn_system/","title":"Enemy Spawn System","text":""},{"location":"dev/RType/enemy_spawn_system/#enemyspawnsystemhpp","title":"EnemySpawnSystem.hpp","text":""},{"location":"dev/RType/enemy_spawn_system/#purpose","title":"Purpose:","text":"<p>The <code>EnemySpawnSystem</code> class is responsible for spawning enemy entities at regular intervals or based on server events, ensuring a consistent and challenging gameplay experience.</p>"},{"location":"dev/RType/enemy_spawn_system/#includes","title":"Includes:","text":"<pre><code>#include \"EnemySpawnSystem.hpp\"\n#include \"Registry.hpp\"\n#include \"Component.hpp\"\n#include &lt;iostream&gt;\n</code></pre>"},{"location":"dev/RType/enemy_spawn_system/#file-description","title":"File Description:","text":"<p>This file defines the <code>EnemySpawnSystem</code>, which handles the creation and initialization of enemy entities. It ensures enemies are added to the game world at appropriate times and positions, with configurable properties like speed and spawn intervals.</p>"},{"location":"dev/RType/enemy_spawn_system/#key-classes-and-functions","title":"Key Classes and Functions:","text":""},{"location":"dev/RType/enemy_spawn_system/#class-enemyspawnsystem","title":"Class: EnemySpawnSystem","text":"<p>Constructor: <pre><code>EnemySpawnSystem(Registry &amp;registry);\n</code></pre> - Initializes the system with a reference to the ECS registry.</p> <p>Functions:</p> <ol> <li>update(float delta_time):</li> <li>Updates the state of the system every frame.</li> <li>Tracks the spawn timer and spawns enemies when the interval elapses.</li> <li> <p>Handles cleanup of off-screen enemies.</p> </li> <li> <p>spawn_enemy_from_server(uint32_t enemyId, float x, float y):</p> </li> <li>Spawns an enemy at a specific position, triggered by server events.</li> </ol>"},{"location":"dev/RType/enemy_spawn_system/#collaboration","title":"Collaboration:","text":"<p>This file interacts with: - Registry: To create new enemy entities and manage components. - GameNetwork: For receiving server instructions to spawn enemies. - Components: Uses <code>Position</code>, <code>Velocity</code>, <code>Drawable</code>, <code>EntityTypeComponent</code>, and <code>Health</code> to define enemy attributes.</p>"},{"location":"dev/RType/enemy_spawn_system/#key-variables","title":"Key Variables:","text":"<ul> <li><code>spawn_timer</code>: Tracks time elapsed since the last enemy spawn.</li> <li><code>spawn_interval</code>: Determines how frequently enemies spawn.</li> <li><code>enemy_speed</code>: Specifies the default speed of spawned enemies.</li> </ul>"},{"location":"dev/RType/enemy_spawn_system/#example-usage","title":"Example Usage:","text":"<pre><code>EnemySpawnSystem enemySpawnSystem(registry);\nwhile (gameRunning) {\n    float deltaTime = GetFrameTime();\n    enemySpawnSystem.update(deltaTime);\n}\n</code></pre>"},{"location":"dev/RType/enemy_spawn_system/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Dynamic Difficulty:</li> <li>The spawn rate and enemy attributes can be adjusted to scale difficulty dynamically.</li> <li>Server Integration:</li> <li>Allows real-time updates to the spawn logic based on server events, ensuring synchronized multiplayer gameplay.</li> <li>Performance:</li> <li>Optimized to handle large numbers of enemies without degrading performance.</li> </ul>"},{"location":"dev/RType/enemy_spawn_system/#summary","title":"Summary:","text":"<p>The <code>EnemySpawnSystem</code> is essential for maintaining a steady flow of challenges in the game. Its integration with the server ensures synchronized enemy spawning across multiplayer sessions, while its modular design allows for easy customization and scalability.</p>"},{"location":"dev/RType/game_common/","title":"Game Common","text":""},{"location":"dev/RType/game_common/#gamecommonhpp","title":"GameCommon.hpp","text":""},{"location":"dev/RType/game_common/#purpose","title":"Purpose:","text":"<p>The <code>GameCommon</code> file provides utility functions for rendering health bars, power-up bars, and other shared gameplay elements. These functions are essential for maintaining consistent and reusable UI components across the game.</p>"},{"location":"dev/RType/game_common/#includes","title":"Includes:","text":"<pre><code>#include &lt;raylib.h&gt;\n#include &lt;iostream&gt;\n</code></pre>"},{"location":"dev/RType/game_common/#file-description","title":"File Description:","text":"<p>This file contains utility functions that assist in rendering graphical elements related to game state, such as health bars and power-up bars. These utilities are designed to be simple and reusable, enabling consistent visuals throughout the game.</p>"},{"location":"dev/RType/game_common/#key-functions","title":"Key Functions:","text":"<ol> <li>draw_health_bar(float x, float y, float width, float height, int current_health, int max_health):</li> <li>Draws a health bar at the specified position and size, reflecting the entity's current health.</li> <li>Health bar color changes dynamically based on the percentage of remaining health.</li> </ol> <p>Parameters:    - <code>x, y</code>: Position of the health bar.    - <code>width, height</code>: Dimensions of the health bar.    - <code>current_health, max_health</code>: Current and maximum health values.</p> <p>Example Usage: <pre><code>draw_health_bar(20, 20, 200, 20, playerHealth.current, playerHealth.max);\n</code></pre></p> <ol> <li>draw_power_up_bar(float x, float y, float width, float height, float progress, bool isActive):</li> <li>Draws a progress bar to indicate the status of a power-up.</li> <li>Bar color changes based on the activation state of the power-up.</li> </ol> <p>Parameters:    - <code>x, y</code>: Position of the power-up bar.    - <code>width, height</code>: Dimensions of the power-up bar.    - <code>progress</code>: Progress ratio (0.0 to 1.0).    - <code>isActive</code>: Boolean indicating if the power-up is active.</p> <p>Example Usage: <pre><code>draw_power_up_bar(20, 50, 200, 20, powerUpProgress, powerUpActive);\n</code></pre></p>"},{"location":"dev/RType/game_common/#collaboration","title":"Collaboration:","text":"<p>This file interacts with: - Rendering Systems: To display health and power-up bars during gameplay. - Game State: Uses values like health and progress provided by components or systems.</p>"},{"location":"dev/RType/game_common/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Reusability:</li> <li>The functions are designed to be generic and adaptable for various entities and scenarios.</li> <li>Performance:</li> <li>Minimal performance impact by relying on efficient drawing calls provided by Raylib.</li> <li>Customization:</li> <li>Easily extendable to include additional UI elements or adapt to different visual styles.</li> </ul>"},{"location":"dev/RType/game_common/#summary","title":"Summary:","text":"<p><code>GameCommon.hpp</code> serves as a collection of utility functions that simplify the rendering of critical gameplay UI elements like health and power-up bars. Its focus on reusability and simplicity ensures consistent and efficient integration across game systems.</p>"},{"location":"dev/RType/game_network/","title":"Game Network","text":""},{"location":"dev/RType/game_network/#gamenetworkhpp","title":"GameNetwork.hpp","text":""},{"location":"dev/RType/game_network/#purpose","title":"Purpose:","text":"<p>The <code>GameNetwork</code> class handles all networking-related functionalities for the R-Type game, enabling communication between the server and the client. This includes player actions, entity synchronization, and event handling.</p>"},{"location":"dev/RType/game_network/#includes","title":"Includes:","text":"<pre><code>#include &lt;arpa/inet.h&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include \"GameNetwork.hpp\"\n#include \"Registry.hpp\"\n</code></pre>"},{"location":"dev/RType/game_network/#file-description","title":"File Description:","text":"<p>This file defines the <code>GameNetwork</code> class, which provides asynchronous networking functionality using the ASIO library. It facilitates communication with the game server, sending and receiving messages for multiplayer synchronization.</p>"},{"location":"dev/RType/game_network/#key-classes-and-functions","title":"Key Classes and Functions:","text":""},{"location":"dev/RType/game_network/#class-gamenetwork","title":"Class: GameNetwork","text":"<p>Constructor: <pre><code>GameNetwork(asio::io_context &amp;io_context, const std::string &amp;serverIP, int udpPort, ECS::Registry &amp;registry);\n</code></pre> - Initializes the network with the specified server IP, port, and ECS registry.</p> <p>Destructor: <pre><code>~GameNetwork();\n</code></pre> - Cleans up any resources or connections during destruction.</p> <p>Functions:</p> <ol> <li>start_send():</li> <li> <p>Begins sending messages asynchronously to the server.</p> </li> <li> <p>start_receive():</p> </li> <li> <p>Listens for incoming messages from the server and processes them.</p> </li> <li> <p>sendConnectMessage(const std::string &amp;username):</p> </li> <li> <p>Sends a connection request to the server with the player\u2019s username.</p> </li> <li> <p>sendDisconnectMessage():</p> </li> <li> <p>Notifies the server that the player is disconnecting.</p> </li> <li> <p>sendMoveMessage(float posX, float posY):</p> </li> <li> <p>Sends the player\u2019s movement updates to the server.</p> </li> <li> <p>sendShootMessage(uint32_t playerId, float posX, float posY, float dirX, float dirY):</p> </li> <li> <p>Sends a shoot action to the server, including projectile position and direction.</p> </li> <li> <p>requestServerInfo(asio::io_context &amp;io_context, int port):</p> </li> <li> <p>Requests a list of available game servers from the server endpoint.</p> </li> <li> <p>handleSpawnEnemyMessage(const char *buffer):</p> </li> <li>Processes server messages to spawn enemies at specific positions.</li> </ol>"},{"location":"dev/RType/game_network/#collaboration","title":"Collaboration:","text":"<p>This file interacts with: - Registry: To update entity states based on server messages. - ECS Components: Manages synchronization of entities like players, enemies, and projectiles. - Server: Communicates using UDP to send/receive game state updates.</p>"},{"location":"dev/RType/game_network/#key-variables","title":"Key Variables:","text":"<ul> <li><code>server_endpoint_</code>: Stores the server\u2019s address and port.</li> <li><code>udpSocket</code>: Handles UDP communication.</li> <li><code>playerIdMap</code>: Maps player IDs to ECS entities for synchronization.</li> </ul>"},{"location":"dev/RType/game_network/#example-usage","title":"Example Usage:","text":"<pre><code>GameNetwork network(io_context, \"127.0.0.1\", 4343, registry);\nnetwork.sendConnectMessage(\"Player1\");\nnetwork.start_receive();\n</code></pre>"},{"location":"dev/RType/game_network/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Asynchronous Communication:</li> <li>Uses ASIO for non-blocking network operations, ensuring smooth gameplay.</li> <li>Multiplayer Support:</li> <li>Handles multiple players, synchronizing their states with minimal latency.</li> <li>Error Handling:</li> <li>Includes mechanisms to retry failed operations or recover from network interruptions.</li> </ul>"},{"location":"dev/RType/game_network/#summary","title":"Summary:","text":"<p>The <code>GameNetwork</code> class is the backbone of multiplayer functionality in the R-Type game. By enabling seamless communication with the server, it ensures synchronized gameplay and a responsive experience for all players.</p>"},{"location":"dev/RType/game_setup/","title":"Game Setup","text":""},{"location":"dev/RType/game_setup/#gamesetuphpp","title":"GameSetup.hpp","text":""},{"location":"dev/RType/game_setup/#purpose","title":"Purpose:","text":"<p>The <code>GameSetup</code> class initializes the ECS (Entity Component System), registers components, and sets up systems necessary for the R-Type game. It also handles the creation of player and enemy entities.</p>"},{"location":"dev/RType/game_setup/#includes","title":"Includes:","text":"<pre><code>#include &lt;raylib.h&gt;\n#include &lt;iostream&gt;\n#include \"GameSetup.hpp\"\n#include \"Component.hpp\"\n#include \"MovementSystem.hpp\"\n#include \"InputSystem.hpp\"\n#include \"ShootingSystem.hpp\"\n#include \"EnemySpawnSystem.hpp\"\n#include \"EnemyShootingSystem.hpp\"\n#include \"CollisionSystem.hpp\"\n#include \"GameCommon.hpp\"\n#include \"RaylibRenderingSystem.hpp\"\n#include \"Health.hpp\"\n</code></pre>"},{"location":"dev/RType/game_setup/#file-description","title":"File Description:","text":"<p>This file contains the <code>GameSetup</code> class, which encapsulates the initialization process for the game. It ensures all ECS components and systems are properly registered and that essential entities like the player are created.</p>"},{"location":"dev/RType/game_setup/#key-functions","title":"Key Functions:","text":""},{"location":"dev/RType/game_setup/#function-initializeecs","title":"Function: initializeECS","text":"<p><pre><code>void initializeECS(ECS::Registry &amp;registry, ECS::SystemManager &amp;systemManager, GameNetwork &amp;network, AudioManager &amp;audioManager, GraphicsManager &amp;graphicsManager, bool &amp;powerUpActive, float &amp;powerUpTimer, float &amp;powerUpProgress);\n</code></pre> - Registers all required components and systems with the ECS. - Systems added include movement, input handling, shooting, enemy spawning, and collision detection.</p>"},{"location":"dev/RType/game_setup/#function-spawnenemy","title":"Function: spawnEnemy","text":"<p><pre><code>void spawnEnemy(ECS::Registry &amp;registry, float x, float y);\n</code></pre> - Spawns an enemy entity at the specified position. - Assigns components like <code>Position</code>, <code>Velocity</code>, <code>Drawable</code>, <code>EntityTypeComponent</code>, and <code>Health</code>.</p>"},{"location":"dev/RType/game_setup/#function-playgame","title":"Function: playGame","text":"<p><pre><code>void playGame(ECS::Registry &amp;registry, ECS::SystemManager &amp;systemManager, GameState &amp;state, GameNetwork &amp;network, AudioManager &amp;audioManager, GraphicsManager &amp;graphicsManager, bool &amp;powerUpActive, float &amp;powerUpTimer, float &amp;powerUpProgress);\n</code></pre> - Handles the main gameplay loop. - Updates systems, checks player state, and renders the game frame by frame.</p>"},{"location":"dev/RType/game_setup/#collaboration","title":"Collaboration:","text":"<p>This file interacts with: - ECS: Registers components and manages systems. - GameNetwork: For player movement and entity synchronization. - GraphicsManager: For rendering sprites and animations. - AudioManager: To play sounds like shooting and explosions.</p>"},{"location":"dev/RType/game_setup/#key-variables","title":"Key Variables:","text":"<ul> <li><code>powerUpActive</code>: Tracks whether a power-up is currently active.</li> <li><code>powerUpTimer</code>: Times the duration of an active power-up.</li> <li><code>powerUpProgress</code>: Tracks progress toward the next power-up activation.</li> </ul>"},{"location":"dev/RType/game_setup/#example-usage","title":"Example Usage:","text":"<pre><code>GameSetup gameSetup;\ngameSetup.initializeECS(registry, systemManager, network, audioManager, graphicsManager, powerUpActive, powerUpTimer, powerUpProgress);\ngameSetup.playGame(registry, systemManager, gameState, network, audioManager, graphicsManager, powerUpActive, powerUpTimer, powerUpProgress);\n</code></pre>"},{"location":"dev/RType/game_setup/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Modularity:</li> <li>Each system and component is initialized independently for flexibility.</li> <li>Scalability:</li> <li>New systems and components can be added without modifying existing code.</li> <li>Performance:</li> <li>Ensures efficient initialization to minimize startup time.</li> </ul>"},{"location":"dev/RType/game_setup/#summary","title":"Summary:","text":"<p><code>GameSetup.hpp</code> orchestrates the initialization and management of all essential systems and components for the R-Type game. It provides the foundation for a smooth and scalable gameplay experience.</p>"},{"location":"dev/RType/health_system/","title":"Health System","text":""},{"location":"dev/RType/health_system/#healthsystemhpp","title":"HealthSystem.hpp","text":""},{"location":"dev/RType/health_system/#purpose","title":"Purpose:","text":"<p>The <code>HealthSystem</code> class manages the health state of game entities, ensuring that health-related events such as entity destruction or shield depletion are handled appropriately.</p>"},{"location":"dev/RType/health_system/#includes","title":"Includes:","text":"<pre><code>#include \"HealthSystem.hpp\"\n#include \"Registry.hpp\"\n#include \"Component.hpp\"\n</code></pre>"},{"location":"dev/RType/health_system/#file-description","title":"File Description:","text":"<p>This file defines the <code>HealthSystem</code>, which is responsible for monitoring and updating the health of entities in the game. The system also ensures that entities are removed or updated when their health reaches zero.</p>"},{"location":"dev/RType/health_system/#key-functions","title":"Key Functions:","text":""},{"location":"dev/RType/health_system/#function-update","title":"Function: update","text":"<p><pre><code>void update(float delta_time);\n</code></pre> - Iterates through all entities with a <code>Health</code> component. - Checks if any entity\u2019s health has dropped to zero or below. - Handles the removal of entities or other logic when health is depleted.</p>"},{"location":"dev/RType/health_system/#collaboration","title":"Collaboration:","text":"<p>This file interacts with: - Registry: To access and modify the <code>Health</code> components of entities. - Components:   - <code>Health</code>: Tracks the current and maximum health of entities.   - Other related components (e.g., <code>ShieldComponent</code>) can be integrated if needed.</p>"},{"location":"dev/RType/health_system/#example-usage","title":"Example Usage:","text":"<pre><code>HealthSystem healthSystem(registry);\nfloat deltaTime = GetFrameTime();\nhealthSystem.update(deltaTime);\n</code></pre>"},{"location":"dev/RType/health_system/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Efficiency:</li> <li>Uses ECS to efficiently process only entities with a <code>Health</code> component.</li> <li>Flexibility:</li> <li>Can be extended to include health regeneration or effects triggered at specific health thresholds.</li> </ul>"},{"location":"dev/RType/health_system/#summary","title":"Summary:","text":"<p>The <code>HealthSystem</code> plays a critical role in ensuring the proper handling of entity health within the game. Its efficient processing and modular design make it a cornerstone of the ECS-based architecture, allowing for future expansions such as healing effects or additional health-based mechanics.</p>"},{"location":"dev/RType/input_system/","title":"Input System","text":""},{"location":"dev/RType/input_system/#inputsystemhpp","title":"InputSystem.hpp","text":""},{"location":"dev/RType/input_system/#purpose","title":"Purpose:","text":"<p>The <code>InputSystem</code> class processes player input for controlling the game, including movement, shooting, and activating power-ups. It interfaces with ECS components to apply these actions to the appropriate entities.</p>"},{"location":"dev/RType/input_system/#includes","title":"Includes:","text":"<pre><code>#include \"InputSystem.hpp\"\n#include \"Registry.hpp\"\n#include \"Component.hpp\"\n#include \"GameNetwork.hpp\"\n#include \"AudioManager.hpp\"\n#include &lt;raylib.h&gt;\n</code></pre>"},{"location":"dev/RType/input_system/#file-description","title":"File Description:","text":"<p>This file defines the <code>InputSystem</code>, which maps player keyboard inputs to entity actions within the game. It supports movement, firing projectiles, and power-up activation.</p>"},{"location":"dev/RType/input_system/#key-functions","title":"Key Functions:","text":""},{"location":"dev/RType/input_system/#function-update","title":"Function: update","text":"<p><pre><code>void update(float delta_time);\n</code></pre> - Iterates through entities with input and velocity components. - Updates velocity based on keyboard inputs for movement. - Handles special actions like shooting and power-up activation.</p>"},{"location":"dev/RType/input_system/#key-features","title":"Key Features:","text":"<ol> <li>Movement Handling:</li> <li> <p>Processes directional inputs (<code>KEY_UP</code>, <code>KEY_DOWN</code>, <code>KEY_LEFT</code>, <code>KEY_RIGHT</code>) to control entity movement.</p> </li> <li> <p>Shooting:</p> </li> <li> <p>Handles the <code>KEY_SPACE</code> input to spawn projectiles at the player's position.</p> </li> <li> <p>Power-Up Activation:</p> </li> <li>Activates power-ups when the <code>KEY_E</code> input is pressed (if available).</li> </ol>"},{"location":"dev/RType/input_system/#collaboration","title":"Collaboration:","text":"<p>This file interacts with: - Registry: To access and modify components like <code>Velocity</code>, <code>Position</code>, and <code>InputComponent</code>. - GameNetwork: To send movement and shooting updates to the server. - AudioManager: To play sound effects for actions like shooting.</p>"},{"location":"dev/RType/input_system/#example-usage","title":"Example Usage:","text":"<pre><code>InputSystem inputSystem(registry, network, audioManager, powerUpActive, powerUpTimer);\nfloat deltaTime = GetFrameTime();\ninputSystem.update(deltaTime);\n</code></pre>"},{"location":"dev/RType/input_system/#key-variables","title":"Key Variables:","text":"<ul> <li><code>powerUpActive</code>: Indicates if a power-up is currently active.</li> <li><code>powerUpTimer</code>: Tracks the remaining time for the active power-up.</li> <li><code>shootingCooldowns</code>: Tracks cooldown periods for firing projectiles.</li> </ul>"},{"location":"dev/RType/input_system/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Real-Time Responsiveness:</li> <li>Ensures minimal latency between player input and game action.</li> <li>Multiplayer Integration:</li> <li>Synchronizes player actions with the server via <code>GameNetwork</code>.</li> <li>Modularity:</li> <li>Easily extendable for new input actions or features.</li> </ul>"},{"location":"dev/RType/input_system/#summary","title":"Summary:","text":"<p>The <code>InputSystem</code> bridges player inputs with in-game actions, ensuring responsive and intuitive gameplay. Its integration with ECS components and the networking system makes it a vital part of the R-Type game.</p>"},{"location":"dev/RType/projectile_types/","title":"Projectile Types","text":""},{"location":"dev/RType/projectile_types/#projectiletypehpp","title":"ProjectileType.hpp","text":""},{"location":"dev/RType/projectile_types/#purpose","title":"Purpose:","text":"<p>Defines the <code>ProjectileType</code> enumeration and associated components to classify and manage different types of projectiles in the game. This ensures flexible handling of projectiles for both players and enemies.</p>"},{"location":"dev/RType/projectile_types/#includes","title":"Includes:","text":"<pre><code>#include \"ProjectileType.hpp\"\n#include \"Component.hpp\"\n</code></pre>"},{"location":"dev/RType/projectile_types/#file-description","title":"File Description:","text":"<p>This file provides an enumeration for projectile types and a component to attach projectile-specific data to entities. It facilitates distinguishing between player and enemy projectiles and customizing their behavior.</p>"},{"location":"dev/RType/projectile_types/#key-enumerations","title":"Key Enumerations:","text":""},{"location":"dev/RType/projectile_types/#enum-projectiletype","title":"Enum: ProjectileType","text":"<p><pre><code>enum class ProjectileType {\n    PLAYER_PROJECTILE,\n    ENEMY_PROJECTILE\n};\n</code></pre> - PLAYER_PROJECTILE: Represents projectiles fired by the player. - ENEMY_PROJECTILE: Represents projectiles fired by enemies.</p>"},{"location":"dev/RType/projectile_types/#key-components","title":"Key Components:","text":""},{"location":"dev/RType/projectile_types/#component-projectiletypecomponent","title":"Component: ProjectileTypeComponent","text":"<p><pre><code>struct ProjectileTypeComponent {\n    ProjectileType type;\n};\n</code></pre> - Encapsulates the type of projectile associated with an entity. - Enables systems to identify and differentiate projectile behavior based on type.</p>"},{"location":"dev/RType/projectile_types/#collaboration","title":"Collaboration:","text":"<p>This file interacts with: - Systems:   - CollisionSystem: To handle interactions between projectiles and other entities.   - EnemyShootingSystem: To spawn enemy projectiles.   - InputSystem: To spawn player projectiles. - Registry: For associating the <code>ProjectileTypeComponent</code> with entities.</p>"},{"location":"dev/RType/projectile_types/#example-usage","title":"Example Usage:","text":"<pre><code>ECS::Entity projectile = registry.spawn_entity();\nregistry.get_components&lt;ECS::ProjectileTypeComponent&gt;().insert_at(\n    static_cast&lt;size_t&gt;(projectile),\n    ECS::ProjectileTypeComponent{ProjectileType::PLAYER_PROJECTILE}\n);\n</code></pre>"},{"location":"dev/RType/projectile_types/#design-considerations","title":"Design Considerations:","text":"<ul> <li>Extensibility:</li> <li>Additional projectile types can be added, such as <code>POWER_UP_PROJECTILE</code> or <code>SPECIAL_ATTACK_PROJECTILE</code>.</li> <li>Efficiency:</li> <li>The simple enumeration allows for quick identification and branching logic in systems.</li> <li>Customizability:</li> <li>Systems can define unique behaviors for each projectile type (e.g., speed, damage, visuals).</li> </ul>"},{"location":"dev/RType/projectile_types/#summary","title":"Summary:","text":"<p><code>ProjectileType.hpp</code> is a foundational file for managing projectile classification and behavior in the R-Type game. Its simplicity and flexibility make it a critical component for gameplay mechanics involving shooting and projectile interactions.</p>"},{"location":"protocol/binary-protocol/","title":"R-Type Multiplayer Protocol Specification","text":""},{"location":"protocol/binary-protocol/#version-20","title":"Version: 2.0","text":"<p>Last Updated: 2024-12-04  </p>"},{"location":"protocol/binary-protocol/#1-general-information","title":"1. General Information","text":"<ul> <li>Protocol: TCP  </li> <li>Port: 4242  </li> <li>Message Format: Binary  </li> <li>Encoding: UTF-8  </li> <li>Packet Header:  </li> <li>Type: 1 byte (indicates message type)  </li> <li>Payload Size: 4 bytes (indicates the size of the payload)  </li> </ul>"},{"location":"protocol/binary-protocol/#2-message-types-and-fields","title":"2. Message Types and Fields","text":"Type Message Description <code>0x01</code> <code>connect</code> Client requests connection to the server <code>0x02</code> <code>connected</code> Server confirms connection and provides initial state <code>0x03</code> <code>disconnect</code> Client requests disconnection <code>0x04</code> <code>player_disconnected</code> Server notifies clients of a player\u2019s disconnection <code>0x05</code> <code>move</code> Client sends updated position <code>0x06</code> <code>update_position</code> Server broadcasts player position updates <code>0x07</code> <code>shoot</code> Client sends a shooting action <code>0x08</code> <code>bullet</code> Server broadcasts bullet position and state <code>0x09</code> <code>spawn_enemy</code> Server broadcasts enemy spawn <code>0x0A</code> <code>update_enemy</code> Server broadcasts enemy movement <code>0x0B</code> <code>update_score</code> Server updates players' scores <code>0x0C</code> <code>chat_message</code> Client sends a chat message <code>0x0D</code> <code>broadcast_chat</code> Server broadcasts a chat message <code>0x0E</code> <code>power_up</code> Server broadcasts a power-up spawn <code>0x0F</code> <code>collect_power_up</code> Client collects a power-up <code>0x10</code> <code>sync_state</code> Server synchronizes game state <code>0x11</code> <code>error</code> Server sends an error message"},{"location":"protocol/binary-protocol/#21-connection-messages","title":"2.1. Connection Messages","text":""},{"location":"protocol/binary-protocol/#client-server-connect","title":"Client \u2192 Server: <code>connect</code>","text":"Field Type Description <code>username</code> STRING Player's username (16 bytes max) <p>Binary Format: | Byte Offset | Size (bytes) | Field  | Description             | |-----------------|------------------|------------|-----------------------------| | 0               | 1                | <code>type</code>     | Message type (<code>0x01</code>)       | | 1               | 4                | <code>size</code>     | Payload size (e.g., 16)     | | 5               | 16               | <code>username</code> | Player's username           |</p>"},{"location":"protocol/binary-protocol/#server-client-connected","title":"Server \u2192 Client: <code>connected</code>","text":"Field Type Description <code>playerId</code> INTEGER Unique player ID assigned by the server <code>gameState</code> OBJECT Current game state"},{"location":"protocol/binary-protocol/#22-gameplay-messages","title":"2.2. Gameplay Messages","text":""},{"location":"protocol/binary-protocol/#client-server-move","title":"Client \u2192 Server: <code>move</code>","text":"Field Type Description <code>playerId</code> INTEGER Player's ID <code>position</code> OBJECT Player's updated coordinates"},{"location":"protocol/binary-protocol/#server-all-clients-update_position","title":"Server \u2192 All Clients: <code>update_position</code>","text":"Field Type Description <code>playerId</code> INTEGER Player's ID <code>position</code> OBJECT Updated coordinates"},{"location":"protocol/binary-protocol/#23-shooting-messages","title":"2.3. Shooting Messages","text":""},{"location":"protocol/binary-protocol/#client-server-shoot","title":"Client \u2192 Server: <code>shoot</code>","text":"Field Type Description <code>playerId</code> INTEGER Player's ID <code>position</code> OBJECT Coordinates of the shot <code>direction</code> STRING Direction of the shot"},{"location":"protocol/binary-protocol/#24-chat-messages","title":"2.4. Chat Messages","text":""},{"location":"protocol/binary-protocol/#client-server-chat_message","title":"Client \u2192 Server: <code>chat_message</code>","text":"Field Type Description <code>username</code> STRING Player's username <code>message</code> STRING Chat message content <p>Binary Format: | Byte Offset | Size (bytes) | Field  | Description             | |-----------------|------------------|------------|-----------------------------| | 0               | 1                | <code>type</code>     | Message type (<code>0x0C</code>)       | | 1               | 4                | <code>size</code>     | Payload size                | | 5               | 16               | <code>username</code> | Player's username           | | 21              | N                | <code>message</code>  | Chat message content        |</p>"},{"location":"protocol/binary-protocol/#25-power-up-messages","title":"2.5. Power-Up Messages","text":""},{"location":"protocol/binary-protocol/#server-all-clients-power_up","title":"Server \u2192 All Clients: <code>power_up</code>","text":"Field Type Description <code>powerUpId</code> INTEGER Unique power-up ID <code>position</code> OBJECT Spawn coordinates <code>type</code> STRING Type of power-up"},{"location":"protocol/binary-protocol/#26-error-handling-messages","title":"2.6. Error Handling Messages","text":""},{"location":"protocol/binary-protocol/#server-client-error","title":"Server \u2192 Client: <code>error</code>","text":"Field Type Description <code>errorCode</code> INTEGER Error code <code>message</code> STRING Error message"},{"location":"protocol/binary-protocol/#3-game-state-synchronization","title":"3. Game State Synchronization","text":"<p>The server periodically sends a <code>sync_state</code> message to all connected clients to ensure they are up-to-date with the game world.</p> Field Type Description <code>players</code> ARRAY List of all players and their states <code>enemies</code> ARRAY List of all enemies and their states <code>powerUps</code> ARRAY List of active power-ups"},{"location":"protocol/binary-protocol/#4-error-codes","title":"4. Error Codes","text":"Error Code Description <code>1001</code> Invalid message format <code>1002</code> Unknown message type <code>1003</code> Player not found <code>1004</code> Action not permitted"},{"location":"protocol/binary-protocol/#5-example-communication-sequence","title":"5. Example Communication Sequence","text":"<ol> <li>Client connects:  </li> <li>Sends <code>connect</code> message with username.  </li> <li> <p>Server responds with <code>connected</code> and player ID.</p> </li> <li> <p>Client moves:  </p> </li> <li>Sends <code>move</code> message with new position.  </li> <li> <p>Server broadcasts <code>update_position</code>.</p> </li> <li> <p>Client shoots:  </p> </li> <li>Sends <code>shoot</code> message with position and direction.  </li> <li> <p>Server broadcasts <code>bullet</code>.</p> </li> <li> <p>Player sends chat:  </p> </li> <li>Sends <code>chat_message</code>.  </li> <li> <p>Server broadcasts <code>broadcast_chat</code>.</p> </li> <li> <p>Game synchronization:  </p> </li> <li>Server periodically sends <code>sync_state</code> to all clients.</li> </ol>"},{"location":"protocol/binary-protocol/#6-packet-structure-overview","title":"6. Packet Structure Overview","text":"Header (Bytes) Field Description 1 <code>type</code> Message type 4 <code>size</code> Payload size N <code>payload</code> Actual message data <p>End of Protocol</p>"},{"location":"protocol/protocol/","title":"R-Type Multiplayer Protocol Specification","text":""},{"location":"protocol/protocol/#version-10","title":"Version: 1.0","text":""},{"location":"protocol/protocol/#last-updated-2024-11-26","title":"Last Updated: 2024-11-26","text":""},{"location":"protocol/protocol/#_1","title":"Overview","text":""},{"location":"protocol/protocol/#1-general-information","title":"1. GENERAL INFORMATION","text":""},{"location":"protocol/protocol/#_2","title":"Overview","text":"<p>PROTOCOL: TCP PORT: 12345 MESSAGE_FORMAT: JSON ENCODING: UTF-8</p>"},{"location":"protocol/protocol/#_3","title":"Overview","text":""},{"location":"protocol/protocol/#2-message-types-and-fields","title":"2. MESSAGE TYPES AND FIELDS","text":""},{"location":"protocol/protocol/#_4","title":"Overview","text":""},{"location":"protocol/protocol/#21-connection-messages","title":"2.1. Connection Messages","text":""},{"location":"protocol/protocol/#client-server","title":"CLIENT \u2192 SERVER","text":"<p>MESSAGE: connect FIELDS:   - username: STRING (Player's chosen username) EXAMPLE: {   \"type\": \"connect\",   \"username\": \"PlayerName\" }</p>"},{"location":"protocol/protocol/#server-client","title":"SERVER \u2192 CLIENT","text":"<p>MESSAGE: connected FIELDS:   - playerId: INTEGER (Unique player ID assigned by the server)   - otherPlayers: ARRAY (List of connected players with their IDs and positions) EXAMPLE: {   \"type\": \"connected\",   \"playerId\": 1,   \"otherPlayers\": [     {       \"playerId\": 2,       \"username\": \"OtherPlayer\",       \"position\": { \"x\": 100, \"y\": 200 }     }   ] }</p>"},{"location":"protocol/protocol/#22-movement-messages","title":"2.2. Movement Messages","text":""},{"location":"protocol/protocol/#client-server_1","title":"CLIENT \u2192 SERVER","text":"<p>MESSAGE: move FIELDS:   - playerId: INTEGER (Player's ID)   - position: OBJECT (New coordinates of the player) EXAMPLE: {   \"type\": \"move\",   \"playerId\": 1,   \"position\": { \"x\": 150, \"y\": 300 } }</p>"},{"location":"protocol/protocol/#server-all-clients","title":"SERVER \u2192 ALL CLIENTS","text":"<p>MESSAGE: update_position FIELDS:   - playerId: INTEGER (Player's ID)   - position: OBJECT (Updated coordinates of the player) EXAMPLE: {   \"type\": \"update_position\",   \"playerId\": 1,   \"position\": { \"x\": 150, \"y\": 300 } }</p>"},{"location":"protocol/protocol/#23-shooting-messages","title":"2.3. Shooting Messages","text":""},{"location":"protocol/protocol/#client-server_2","title":"CLIENT \u2192 SERVER","text":"<p>MESSAGE: shoot FIELDS:   - playerId: INTEGER (Player's ID)   - position: OBJECT (Coordinates where the bullet is fired)   - direction: STRING (Direction of the shot, e.g., \"left\", \"right\") EXAMPLE: {   \"type\": \"shoot\",   \"playerId\": 1,   \"position\": { \"x\": 200, \"y\": 320 },   \"direction\": \"right\" }</p>"},{"location":"protocol/protocol/#server-all-clients_1","title":"SERVER \u2192 ALL CLIENTS","text":"<p>MESSAGE: bullet FIELDS:   - playerId: INTEGER (Player's ID who fired)   - position: OBJECT (Coordinates where the bullet is)   - direction: STRING (Direction of the shot, e.g., \"left\", \"right\")   - source: STRING (Indicates the source of the bullet: \"self\", \"ally\", or \"enemy\") EXAMPLE: {   \"type\": \"bullet\",   \"playerId\": 1,   \"position\": { \"x\": 200, \"y\": 320 },   \"direction\": \"right\",   \"source\": \"self\" }</p>"},{"location":"protocol/protocol/#24-enemy-spawn-messages","title":"2.4. Enemy Spawn Messages","text":""},{"location":"protocol/protocol/#server-all-clients_2","title":"SERVER \u2192 ALL CLIENTS","text":"<p>MESSAGE: spawn_enemy FIELDS:   - enemyId: INTEGER (Unique ID of the enemy)   - position: OBJECT (Spawn coordinates of the enemy) EXAMPLE: {   \"type\": \"spawn_enemy\",   \"enemyId\": 101,   \"position\": { \"x\": 800, \"y\": 250 } }</p>"},{"location":"protocol/protocol/#25-enemy-update-messages","title":"2.5. Enemy Update Messages","text":""},{"location":"protocol/protocol/#server-all-clients_3","title":"SERVER \u2192 ALL CLIENTS","text":"<p>MESSAGE: update_enemy FIELDS:   - enemyId: INTEGER (Unique ID of the enemy)   - position: OBJECT (Updated coordinates of the enemy) EXAMPLE: {   \"type\": \"update_enemy\",   \"enemyId\": 101,   \"position\": { \"x\": 750, \"y\": 250 } }</p>"},{"location":"protocol/protocol/#26-score-update-messages","title":"2.6. Score Update Messages","text":""},{"location":"protocol/protocol/#server-all-clients_4","title":"SERVER \u2192 ALL CLIENTS","text":"<p>MESSAGE: update_score FIELDS:   - playerId: INTEGER (ID of the player)   - score: INTEGER (Player's current score) EXAMPLE: {   \"type\": \"update_score\",   \"playerId\": 1,   \"score\": 5000 }</p>"},{"location":"protocol/protocol/#27-disconnection-messages","title":"2.7. Disconnection Messages","text":""},{"location":"protocol/protocol/#client-server_3","title":"CLIENT \u2192 SERVER","text":"<p>MESSAGE: disconnect FIELDS:   - playerId: INTEGER (ID of the disconnecting player) EXAMPLE: {   \"type\": \"disconnect\",   \"playerId\": 1 }</p>"},{"location":"protocol/protocol/#server-all-clients_5","title":"SERVER \u2192 ALL CLIENTS","text":"<p>MESSAGE: player_disconnected FIELDS:   - playerId: INTEGER (ID of the player who disconnected) EXAMPLE: {   \"type\": \"player_disconnected\",   \"playerId\": 1 }</p>"},{"location":"protocol/protocol/#_5","title":"Overview","text":""},{"location":"protocol/protocol/#3-gameplay-cycle","title":"3. GAMEPLAY CYCLE","text":""},{"location":"protocol/protocol/#_6","title":"Overview","text":"<ol> <li>Connection Initialization:</li> <li>The client sends a <code>connect</code> message with a chosen username.</li> <li> <p>The server responds with <code>connected</code> containing the player ID and the list of other connected players.</p> </li> <li> <p>Gameplay Interaction:</p> </li> <li>The client sends <code>move</code> and <code>shoot</code> messages to the server.</li> <li> <p>The server broadcasts <code>update_position</code>, <code>bullet</code>, <code>spawn_enemy</code>, and <code>update_enemy</code> messages to all clients.</p> </li> <li> <p>Score Management:</p> </li> <li> <p>The server periodically sends <code>update_score</code> to all clients.</p> </li> <li> <p>Disconnection:</p> </li> <li>The client sends a <code>disconnect</code> message.</li> <li>The server notifies other clients using <code>player_disconnected</code>.</li> </ol>"},{"location":"protocol/protocol/#_7","title":"Overview","text":""},{"location":"protocol/protocol/#end-of-protocol","title":"END OF PROTOCOL","text":""},{"location":"protocol/protocol/#_8","title":"Overview","text":""},{"location":"user/Installation/","title":"Installation and Setup","text":""},{"location":"user/Installation/#system-requirements","title":"System Requirements","text":"<p>To successfully install and run the project, ensure your system meets the following requirements:</p> <ul> <li>Operating System: Linux, macOS, or Windows (Windows Subsystem for Linux recommended for Windows users).</li> <li>Compiler: GCC 9.3 or higher, or Clang 11.0 or higher.</li> <li>Dependencies:</li> <li>CMake 3.15 or higher</li> <li>Make</li> <li>Raylib library</li> <li>ASIO library</li> <li>JSON for Modern C++</li> <li>Network utilities (for socket programming)</li> <li>Hardware: At least 2GB of free RAM and a dual-core processor.</li> </ul>"},{"location":"user/Installation/#installation-steps","title":"Installation Steps","text":""},{"location":"user/Installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<p>Download the project from the repository using Git: <pre><code>$ git clone https://github.com/your-repo/rtype-project.git\n$ cd rtype-project\n</code></pre></p>"},{"location":"user/Installation/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>Ensure all dependencies are installed on your system:</p>"},{"location":"user/Installation/#on-linux","title":"On Linux:","text":"<pre><code>$ sudo apt update\n$ sudo apt install build-essential cmake libasio-dev libraylib-dev libjsoncpp-dev\n</code></pre>"},{"location":"user/Installation/#on-macos","title":"On macOS:","text":"<pre><code>$ brew update\n$ brew install cmake raylib asio jsoncpp\n</code></pre>"},{"location":"user/Installation/#on-windows","title":"On Windows:","text":"<ul> <li>Install a compatible compiler such as MinGW or MSVC.</li> <li>Use a package manager like <code>vcpkg</code> to install libraries:   <pre><code>vcpkg install asio raylib jsoncpp\n</code></pre></li> </ul>"},{"location":"user/Installation/#3-build-the-project","title":"3. Build the Project","text":"<p>Create a build directory and compile the project using CMake: <pre><code>$ mkdir build &amp;&amp; cd build\n$ cmake ..\n$ make\n</code></pre></p>"},{"location":"user/Installation/#4-run-the-application","title":"4. Run the Application","text":"<p>To launch the server: <pre><code>$ ./rtype-server\n</code></pre> To launch the client: <pre><code>$ ./rtype-client\n</code></pre></p>"},{"location":"user/Installation/#first-run","title":"First Run","text":"<ol> <li>Start the server:    <pre><code>$ ./rtype-server\n</code></pre></li> <li> <p>The server will initialize and begin listening for connections on the default port.</p> </li> <li> <p>Start the client:    <pre><code>$ ./rtype-client\n</code></pre></p> </li> <li> <p>Enter the server's IP address and your username to connect.</p> </li> <li> <p>Verify the connection:</p> </li> <li>The client should display a successful connection message.</li> <li>The server console should log the new connection.</li> </ol>"},{"location":"user/Installation/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If you encounter issues:</li> <li>Ensure all dependencies are installed.</li> <li>Check that the server is running and reachable from the client.</li> <li>Verify the firewall settings to allow traffic on the specified ports.</li> </ul> <p>If you experience further issues, consult the documentation or reach out to the support team.</p>"},{"location":"user/Introduction/","title":"User Documentation: Introduction","text":""},{"location":"user/Introduction/#what-is-the-project","title":"What is the Project?","text":"<p>This project is a multiplayer space shooter game designed with an Entity-Component-System (ECS) architecture. It provides a dynamic and scalable platform for creating engaging multiplayer experiences. The project aims to deliver a seamless blend of gameplay, customization, and development flexibility.</p>"},{"location":"user/Introduction/#key-features","title":"Key Features","text":"<ul> <li>Multiplayer Gameplay: Connect with friends or players worldwide to battle in real-time.</li> <li>Entity-Component-System Architecture: A modular design that promotes scalability and clean separation of logic.</li> <li>Customizable Systems: Add new features or modify existing ones with ease.</li> <li>Interactive Gameplay:</li> <li>Power-ups to enhance abilities.</li> <li>Varied enemies with unique behaviors.</li> <li>Competitive scoring system.</li> <li>Cross-Platform Compatibility: Runs on major operating systems with minimal setup.</li> </ul>"},{"location":"user/Introduction/#who-is-it-for","title":"Who Is It For?","text":"<p>This project is for: - Gamers: Enjoy a fast-paced, competitive space shooter. - Developers: Experiment with and expand upon an ECS-based architecture. - Game Designers: Prototype and customize game mechanics. - Educators and Learners: Understand and demonstrate ECS principles.</p>"},{"location":"user/Introduction/#what-can-you-do-with-it","title":"What Can You Do with It?","text":"<ul> <li>Host and manage your own multiplayer game server.</li> <li>Customize gameplay by adding new entities, components, or systems.</li> <li>Extend functionality by integrating new features into the existing architecture.</li> <li>Explore ECS principles in a practical, engaging environment.</li> </ul>"},{"location":"user/Introduction/#why-choose-this-project","title":"Why Choose This Project?","text":"<p>This project combines a powerful backend with exciting gameplay. Whether you want to learn about ECS, host a multiplayer game, or build a modifiable game framework, this project provides the tools and flexibility you need.</p> <p>In the next sections, you'll learn how to get started, play the game, set up the server, and even customize or extend the project to meet your needs.</p>"},{"location":"user/Troubleshooting/","title":"Troubleshooting","text":"<p>This section addresses common issues users may encounter while using the R-Type project and provides guidance for resolving them.</p>"},{"location":"user/Troubleshooting/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"user/Troubleshooting/#1-unable-to-connect-to-server","title":"1. Unable to Connect to Server","text":"<p>Symptoms: - Error message: \"Connection failed.\" - Client unable to join a game.</p> <p>Possible Causes and Solutions: - Server is not running: Ensure the server is started and listening on the correct port.   <pre><code>./rtype_server\n</code></pre> - Firewall blocking the connection: Allow the R-Type server and client through the firewall.   - For example, on Linux:     <pre><code>sudo ufw allow 4242\nsudo ufw allow 4243\n</code></pre> - Incorrect IP address or port: Double-check the server IP and port entered in the client. - Network issues: Ensure both client and server machines are on the same network or accessible via the internet.</p>"},{"location":"user/Troubleshooting/#2-game-crashes-on-launch","title":"2. Game Crashes on Launch","text":"<p>Symptoms: - The application exits abruptly. - Error messages related to missing files or libraries.</p> <p>Possible Causes and Solutions: - Missing dependencies: Ensure all required libraries are installed. Re-run the build process or install missing dependencies listed in the installation guide. - Corrupt installation: Reinstall the game by rebuilding from source or re-downloading the binaries.</p>"},{"location":"user/Troubleshooting/#3-gameplay-lag-or-stuttering","title":"3. Gameplay Lag or Stuttering","text":"<p>Symptoms: - Delays in controls or visuals. - Freezing during gameplay.</p> <p>Possible Causes and Solutions: - High CPU/GPU usage:   - Close unnecessary applications to free up system resources.   - Lower graphics settings in the \"Settings\" menu. - Network latency:   - Use a wired connection for better stability.   - Ensure the server is hosted on a reliable network.</p>"},{"location":"user/Troubleshooting/#4-incorrect-or-missing-visuals","title":"4. Incorrect or Missing Visuals","text":"<p>Symptoms: - Black screen or missing textures.</p> <p>Possible Causes and Solutions: - Graphics driver issues: Update your GPU drivers to the latest version. - Corrupt assets: Verify that the <code>assets/</code> folder is complete and contains all necessary files.</p>"},{"location":"user/Troubleshooting/#5-unable-to-save-or-load-progress","title":"5. Unable to Save or Load Progress","text":"<p>Symptoms: - Game progress is not saved. - \"Failed to load save file\" error.</p> <p>Possible Causes and Solutions: - Insufficient permissions: Ensure the game has write permissions to the save directory. - Corrupt save files: Delete or back up existing save files and try again.</p>"},{"location":"user/Troubleshooting/#6-audio-issues","title":"6. Audio Issues","text":"<p>Symptoms: - No sound or distorted audio.</p> <p>Possible Causes and Solutions: - Muted system sound: Verify the system audio is enabled and volume is sufficient. - Audio device mismatch: Check the selected output device in your system's audio settings. - Missing codecs: Install required audio codecs.</p>"},{"location":"user/Troubleshooting/#contacting-support","title":"Contacting Support","text":"<p>If you encounter issues that are not resolved by the steps above:</p> <ol> <li>Check the Logs:</li> <li>Review the log files generated by the server and client for error messages.</li> <li> <p>Logs are located in the <code>logs/</code> directory by default.</p> </li> <li> <p>Reach Out:</p> </li> <li>Visit the official repository for bug reporting and troubleshooting.</li> <li> <p>Include details such as:</p> <ul> <li>Steps to reproduce the issue.</li> <li>System specifications (OS, hardware).</li> <li>Error messages or screenshots.</li> </ul> </li> <li> <p>Community Forums:</p> </li> <li>Join the R-Type user forums to seek help from the community.</li> </ol> <p>By following these troubleshooting steps, most common issues can be resolved efficiently, ensuring a smooth and enjoyable experience with R-Type.</p>"},{"location":"user/Usage/","title":"Usage","text":"<p>This section explains how to use the R-Type project once it is installed and set up. It covers launching the game, navigating menus, and interacting with the gameplay systems.</p>"},{"location":"user/Usage/#running-the-game","title":"Running the Game","text":"<ol> <li>Start the Server:</li> <li>Open a terminal and navigate to the server executable's directory.</li> <li>Run the server:      <pre><code>./rtype_server\n</code></pre></li> <li> <p>The server will initialize and begin listening for connections.</p> </li> <li> <p>Start the Client:</p> </li> <li>Open a terminal and navigate to the client executable's directory.</li> <li>Run the client:      <pre><code>./rtype_client\n</code></pre></li> <li>You will be prompted to connect to the server.</li> </ol>"},{"location":"user/Usage/#connecting-to-a-server","title":"Connecting to a Server","text":"<ol> <li>Launch the client.</li> <li>Enter the server's IP address and port when prompted.</li> <li>Enter your username.</li> <li>Once connected, you will join the game lobby or an available room.</li> </ol>"},{"location":"user/Usage/#navigating-the-game-menu","title":"Navigating the Game Menu","text":"<ol> <li>Use the arrow keys to navigate menu options.</li> <li>Press Enter to select an option.</li> <li>Menu options include:</li> <li>Start Game: Join an available game or create a new one.</li> <li>Settings: Adjust audio, video, and control settings.</li> <li>Exit: Quit the application.</li> </ol>"},{"location":"user/Usage/#gameplay-instructions","title":"Gameplay Instructions","text":""},{"location":"user/Usage/#controls","title":"Controls","text":"<ul> <li>Movement: Use the arrow keys for directional movement.</li> <li>Shooting: Press the spacebar to fire your weapon.</li> <li>Special Abilities: Use the <code>E</code> key to activate power-ups.</li> </ul>"},{"location":"user/Usage/#objectives","title":"Objectives","text":"<ul> <li>Destroy enemy ships and avoid incoming projectiles.</li> <li>Collect power-ups to enhance your abilities.</li> <li>Survive waves of enemies to progress through levels.</li> <li>Collaborate with other players in multiplayer mode.</li> </ul>"},{"location":"user/Usage/#multiplayer","title":"Multiplayer","text":"<ol> <li>Ensure the server is running.</li> <li>Launch the client and connect to the server.</li> <li>Join a game room with other players or create a new room.</li> <li>Work together to defeat enemies and achieve the objectives.</li> </ol>"},{"location":"user/Usage/#saving-and-loading-progress","title":"Saving and Loading Progress","text":"<ul> <li>The game supports saving progress automatically at the end of each level.</li> <li>To load a previous session:</li> <li>Navigate to the \"Load Game\" option in the main menu.</li> <li>Select the saved session to resume.</li> </ul> <p>This section provides an overview of using the R-Type project, ensuring users can connect, navigate, and enjoy the game effectively. For advanced configurations or customizations, refer to the relevant sections in the documentation.</p>"}]}